"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9266],{425:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var s=i(5893),t=i(1151);const l={sidebar_label:"PAModel",title:"PAModel"},r=void 0,o={id:"api_reference/PAModel",title:"PAModel",description:"PAModel Objects",source:"@site/docs/api_reference/PAModel.md",sourceDirName:"api_reference",slug:"/api_reference/PAModel",permalink:"/PAModelpy/api_reference/PAModel",draft:!1,unlisted:!1,editUrl:"https://github.com/SamiralVdB/PAModelpy/tree/main/docs/docs/api_reference/PAModel.md",tags:[],version:"current",frontMatter:{sidebar_label:"PAModel",title:"PAModel"},sidebar:"tutorialSidebar",previous:{title:"PAMValidator",permalink:"/PAModelpy/api_reference/PAMValidator"},next:{title:"configuration",permalink:"/PAModelpy/api_reference/configuration"}},c={},d=[{value:"PAModel Objects",id:"pamodel-objects",level:2},{value:"P_TOT_DEFAULT",id:"p_tot_default",level:4},{value:"__init__",id:"__init__",level:4},{value:"add_enzymes",id:"add_enzymes",level:4},{value:"add_sectors",id:"add_sectors",level:4},{value:"add_sector",id:"add_sector",level:4},{value:"add_catalytic_events",id:"add_catalytic_events",level:4},{value:"add_enzyme_constraints",id:"add_enzyme_constraints",level:4},{value:"add_sector_constraints",id:"add_sector_constraints",level:4},{value:"add_total_protein_constraint",id:"add_total_protein_constraint",level:4},{value:"add_reactions",id:"add_reactions",level:4},{value:"add_lb_ub_constraints",id:"add_lb_ub_constraints",level:4},{value:"make_lb_ub_constraint",id:"make_lb_ub_constraint",level:4},{value:"make_enzyme_min_max_constraint",id:"make_enzyme_min_max_constraint",level:4},{value:"parse_shadow_prices",id:"parse_shadow_prices",level:4},{value:"calculate_csc",id:"calculate_csc",level:4},{value:"calculate_esc",id:"calculate_esc",level:4},{value:"calculate_sum_of_enzymes",id:"calculate_sum_of_enzymes",level:4},{value:"change_total_protein_constraint",id:"change_total_protein_constraint",level:4},{value:"change_reaction_bounds",id:"change_reaction_bounds",level:4},{value:"change_enzyme_bounds",id:"change_enzyme_bounds",level:4},{value:"get_enzymes_with_reaction_id",id:"get_enzymes_with_reaction_id",level:4},{value:"get_reactions_with_enzyme_id",id:"get_reactions_with_enzyme_id",level:4},{value:"change_kcat_value",id:"change_kcat_value",level:4},{value:"remove_enzymes",id:"remove_enzymes",level:4},{value:"remove_reactions",id:"remove_reactions",level:4},{value:"remove_catalytic_events",id:"remove_catalytic_events",level:4},{value:"remove_sectors",id:"remove_sectors",level:4},{value:"test",id:"test",level:4},{value:"pfba",id:"pfba",level:4},{value:"reset_objective",id:"reset_objective",level:4},{value:"optimize",id:"optimize",level:4},{value:"copy",id:"copy",level:4}];function a(e){const n={code:"code",em:"em",h2:"h2",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"pamodel-objects",children:"PAModel Objects"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class PAModel(Model)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Class representation for a cobra model extended with enzyme kinetics as published in Alter et al. (2021)."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"id_or_model"})," ",(0,s.jsx)(n.em,{children:"str or Model"})," - String to use as model id, or actual model to base new model on.\nIf a string, it is used as input to load a model from. If a model, a new model object is instantiated with\nthe same properties as the original model (default None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"})," ",(0,s.jsx)(n.em,{children:"str, optional"})," - Human-readable string to be model description (default None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"p_tot"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - Total protein concentration (condition-dependent) (unit g_prot/g_cdw) (default 0.285)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"senstitivity"})," ",(0,s.jsx)(n.em,{children:"bool"})," - Boolean value whether or not a sensitivity analysis should be performed during each simulation.\nThis sensitivity analysis will indicate to which extent individual constraints contribute to the objective value.\nEnzyme sectors (EnzymeSector objects, optional): Information about the different enzyme sectors, including:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Active_enzyme: Metabolic active proteins."}),"\n",(0,s.jsx)(n.li,{children:"Transl_enzyme: Enzymes related to translation."}),"\n",(0,s.jsx)(n.li,{children:"Unused_enzymes: Excess enzymes."}),"\n",(0,s.jsx)(n.li,{children:"Custom_enzymes (list): Custom enzyme sectors."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"configuration"})," ",(0,s.jsx)(n.em,{children:"Config object, optional"})," - Information about the general configuration of the model, including\nidentifier conventions. Default as defined in the ",(0,s.jsx)(n.code,{children:"PAModelpy.configuration"})," script for the E.coli iML1515 model."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Attributes"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"p_tot"})," ",(0,s.jsx)(n.em,{children:"float"})," - The fraction of biomass allocated to proteins (units: g_prot/g_cdw)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reactions"})," ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the reaction identifier and the value is a Reaction."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"metabolites"})," ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the metabolite identifier and the value is a Metabolite."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"genes"})," ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the gene identifier and the value is a Gene."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"0 ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the group identifier and the value is a Group."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"1 ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the enzyme identifier and the value is an Enzyme."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"2 ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the enzyme variable identifier and the value is an EnzymeVariable."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"3 ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the catalytic event identifier and the value is a CatalyticEvent."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"4 ",(0,s.jsx)(n.em,{children:"dict"})," - A dictionary containing sector-specific constraints."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"5 ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the sector identifier and the value is an EnzymeSector."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"p_tot_default",children:"P_TOT_DEFAULT"}),"\n",(0,s.jsx)(n.p,{children:"g_protein/g_cdw"}),"\n",(0,s.jsx)(n.h4,{id:"__init__",children:"__init__"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def __init__(id_or_model: Union[str, "Model", None] = None,\n             name: Optional[str] = None,\n             p_tot: Optional[float] = Config.P_TOT_DEFAULT,\n             sensitivity: bool = True,\n             active_sector: Optional[ActiveEnzymeSector] = None,\n             translational_sector: Optional[TransEnzymeSector] = None,\n             unused_sector: Optional[UnusedEnzymeSector] = None,\n             custom_sectors: Union[List, CustomSector] = None,\n             configuration=Config)\n'})}),"\n",(0,s.jsx)(n.p,{children:"Constants"}),"\n",(0,s.jsx)(n.h4,{id:"add_enzymes",children:"add_enzymes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_enzymes(enzyme_list: list) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Add new enzymes to a model.\nAdapted from Cobra.core.model.add_reactions and Cobra.core.model.add_metabolites."}),"\n",(0,s.jsx)(n.p,{children:"This function will add a DictList of enzymes to the model object and add new variables accordingly.\nFor each enzyme-associated reaction, a constraint in each direction is added to the model.\nThe change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enzyme_list"})," ",(0,s.jsx)(n.em,{children:"list or Enzyme"})," - A list of ",(0,s.jsx)(n.code,{children:"Enzyme"})," objects. If it isn't an iterable container, the enzyme will\nbe placed into a list."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_sectors",children:"add_sectors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_sectors(sectors: List = None)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Adds sector variables to the model and adds these to the total protein constraint."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sectors"})," ",(0,s.jsx)(n.em,{children:"list"})," - A list of PAModelpy.EnzymeSectors to add to the model."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_sector",children:"add_sector"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_sector(sector)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Adds the sector variable for a specific sector to the model and adds this to the total protein constraint.\nAlso stores the sector variables in the model attributes."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sector"})," ",(0,s.jsx)(n.em,{children:"PAModelpy.EnzymeSector"})," - The specific EnzymeSector to add to the model."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_catalytic_events",children:"add_catalytic_events"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_catalytic_events(catalytic_events: Optional[Iterable])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Add a new CatalyticEvent to the model.\nWill add a list of CatalyticEvent variables to the model object using the function defined in the CatalyticEvent object."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"catalytic_events"})," ",(0,s.jsx)(n.em,{children:"list or variables.CatalyticEvent"})," - A list of ",(0,s.jsx)(n.code,{children:"variables.CatalyticEvent"})," objects. If it isn't\nan iterable container, the catalytic event will be placed into a list."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_enzyme_constraints",children:"add_enzyme_constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_enzyme_constraints(constraint_list: Optional[list])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Add new enzyme constraints to a model.\nWill add a list of constraints to the model object and add new constraints accordingly.\nThe change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"constraint_list"})," ",(0,s.jsx)(n.em,{children:"list, str, or constraints.Constraint"})," - A list of ",(0,s.jsx)(n.code,{children:"constraints.Constraint"})," objects. If it isn't\nan iterable container, the constraint will be placed into a list. Also, a string with the constraint id\ncan be provided. A constraint will be created before adding it to the model."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_sector_constraints",children:"add_sector_constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_sector_constraints(constraint_list: Optional[list])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Add a new constraint related to a sector to a model.\nWill add a list of constraints to the model object and add new constraints accordingly.\nThe change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"constraint_list"})," ",(0,s.jsx)(n.em,{children:"list or constraints.Constraint"})," - A list of ",(0,s.jsx)(n.code,{children:"constraints.Constraint"})," objects. If it isn't an iterable\ncontainer, the constraint will be placed into a list."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_total_protein_constraint",children:"add_total_protein_constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_total_protein_constraint(p_tot: Optional[float] = P_TOT_DEFAULT)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Function which adds the total protein constraint to the model.\nThis limits the amount of available enzymes and thus the resulting fluxes."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"The constraint expression looks like this:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["``Etot",(0,s.jsx)(n.code,{children:" - sum(E) + E_translprot + E_unusedprot  == p_tot - E_trsn_0 - E_ue_0"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"p_tot"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - Fraction of biomass which consists of protein (g_protein/g_cdw).\nDefault is 0.258 (E.coli)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_reactions",children:"add_reactions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_reactions(reaction_list: Iterable[Reaction]) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Add reactions to the model.\nThis method is superimposed upon the cobra.Model.add_reactions() function.\nAs a new feature, it will add constraints to determine the lower and upper bound if a sensitivity analysis should\nbe performed (which is determined by the model attribute: PAModel.sensitivity).\nReactions with identifiers identical to a reaction already in the model are ignored.\nThe change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reaction_list"})," ",(0,s.jsx)(n.em,{children:"list"})," - A list of ",(0,s.jsx)(n.code,{children:"cobra.Reaction"})," objects."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_lb_ub_constraints",children:"add_lb_ub_constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_lb_ub_constraints()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Makes additional constraints for the reaction lower bounds and upperbounds.\nBy adding these constraints the shadow prices of the reaction bounds can be\ncalculated and used in sensitivity analysis"}),"\n",(0,s.jsx)(n.h4,{id:"make_lb_ub_constraint",children:"make_lb_ub_constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"@staticmethod\ndef make_lb_ub_constraint(m: Optional[Model], rxn: Reaction,\n                          lower_bound: float, upper_bound: float)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Adding variables and constraints for the lower and upper bounds of a reaction to a model.\nWhen solving the model, shadow prices for the lower and upper bounds will be calculated.\nThis allows for the calculation of sensitivity coefficients. The constraints are formulated as follows:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Constraints are formulated as follows:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"R_ub: R_fwd - R_rev <= UB"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"R_lb: -(R_fwd - R_rev) <= -LB"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"m"})," ",(0,s.jsx)(n.em,{children:"cobra.Model or PAModelpy.PAModel"})," - The model to which the upper and lower bound constraints and variables\nshould be added."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rxn"})," ",(0,s.jsx)(n.em,{children:"cobra.Reaction"})," - The reaction for which upper and lower bound constraints should be generated."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lower_bound"})," ",(0,s.jsx)(n.em,{children:"float"})," - The value of the lower bound."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"upper_bound"})," ",(0,s.jsx)(n.em,{children:"float"})," - The value of the upper bound."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"m"})," ",(0,s.jsx)(n.em,{children:"cobra.Model or PAModelpy.PAModel"})," - The model with additional constraints and variables for the reactions."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"make_enzyme_min_max_constraint",children:"make_enzyme_min_max_constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"@staticmethod\ndef make_enzyme_min_max_constraint(m: Optional[Model], enz: Enzyme,\n                                   lower_bound: float, upper_bound: float)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Adding variables and constraints for the lower and upper bounds of an enzyme's concentration to a model.\nWhen solving the model, shadow prices for the lower and upper bounds will be calculated.\nThis allows for the calculation of sensitivity coefficients."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"The constraints are formulated as follows:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"E_ub: E <= Emax"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"E_lb: -E <= -Emin"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"m"})," ",(0,s.jsx)(n.em,{children:"cobra.Model or PAModelpy.PAModel"})," - The model to which the upper and lower bound constraints and variables\nshould be added."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rxn"})," ",(0,s.jsx)(n.em,{children:"PAModelpy.Enzyme"})," - The enzyme for which minimal and maximal concentration constraints should be generated."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lower_bound"})," ",(0,s.jsx)(n.em,{children:"float"})," - The value of the lower bound."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"upper_bound"})," ",(0,s.jsx)(n.em,{children:"float"})," - The value of the upper bound."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"m"})," ",(0,s.jsx)(n.em,{children:"cobra.Model or PAModelpy.PAModel"})," - The model with additional constraints and variables for the enzyme's\nconcentration."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"parse_shadow_prices",children:"parse_shadow_prices"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"@staticmethod\ndef parse_shadow_prices(shadow_prices)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Parse the shadow prices to a DataFrame where each constraint corresponds to a row, and shadow prices and directions are columns."}),"\n",(0,s.jsx)(n.h4,{id:"calculate_csc",children:"calculate_csc"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def calculate_csc(obj_value, mu, mu_ub, mu_lb, mu_ec_f, mu_ec_b)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Calculate the capacity sensitivity coefficient for all inequality constraints in the model.\nThe sum of all capacity sensitivity coefficients should equal 1 for growth maximization."}),"\n",(0,s.jsx)(n.p,{children:"Capacity Sensitivity Coefficient Calculation:\nCapacity Sensitivity Coefficient = constraint_UB * shadowprice / obj_value"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"obj_value"})," ",(0,s.jsx)(n.em,{children:"float"})," - The objective value of the model."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu"})," ",(0,s.jsx)(n.em,{children:"DataFrame"})," - Shadow prices for all constraints."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ub"})," ",(0,s.jsx)(n.em,{children:"DataFrame"})," - Shadow prices for the reaction upper bound (UB) constraints."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_lb"})," ",(0,s.jsx)(n.em,{children:"DataFrame"})," - Shadow prices for the reaction lower bound (LB) constraints."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ec_f"})," ",(0,s.jsx)(n.em,{children:"DataFrame"})," - Shadow prices for the constraints related to enzymatic catalysis of the forward reaction."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ec_b"})," ",(0,s.jsx)(n.em,{children:"DataFrame"})," - Shadow prices for the constraints related to enzymatic catalysis of the backward reaction."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"None"}),"\n",(0,s.jsxs)(n.p,{children:["Results are saved in the ",(0,s.jsx)(n.code,{children:"self.capacity_sensitivity_coefficients"})," attribute as a DataFrame."]}),"\n",(0,s.jsx)(n.h4,{id:"calculate_esc",children:"calculate_esc"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def calculate_esc(obj_value, mu_ec_f, mu_ec_b)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Calculate enzyme sensitivity coefficients for the enzyme variables using their primal values,\nthe objective value, and shadow prices according to the following relations:"}),"\n",(0,s.jsx)(n.p,{children:"Enzyme Sensitivity Coefficient Calculation:\nesc = enzyme_variable.primal * constraint.shadowprice / obj_value"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"obj_value"})," ",(0,s.jsx)(n.em,{children:"float"})," - The objective value from the most recent optimal solution."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ec_f"})," ",(0,s.jsx)(n.em,{children:"pd.DataFrame"})," - Shadow prices for maximizing enzyme concentrations (forward variables)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ec_b"})," ",(0,s.jsx)(n.em,{children:"pd.DataFrame"})," - Shadow prices for minimizing enzyme concentrations (reverse variables)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"None"}),"\n",(0,s.jsxs)(n.p,{children:["Fills the ",(0,s.jsx)(n.code,{children:"PAModel.enzyme_sensitivity_coefficients"})," dataframe with the calculated enzyme sensitivity coefficients."]}),"\n",(0,s.jsx)(n.h4,{id:"calculate_sum_of_enzymes",children:"calculate_sum_of_enzymes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def calculate_sum_of_enzymes()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Calculate the sum of all enzyme variables for a feasible solution."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"float"})," - The sum of all enzyme variables in milligrams per gram of cell dry weight per hour (mg/gCDW/h)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"change_total_protein_constraint",children:"change_total_protein_constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def change_total_protein_constraint(p_tot)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Change the fraction of biomass that is allocated to active proteins."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"p_tot"})," ",(0,s.jsx)(n.em,{children:"float"})," - The new proteome fraction in grams of protein per gram of cell dry weight (g_protein/g_cdw)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"change_reaction_bounds",children:"change_reaction_bounds"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def change_reaction_bounds(rxn_id: str,\n                           lower_bound: float = None,\n                           upper_bound: float = None)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Change the reaction bounds. If a sensitivity analysis is required, the bounds of the upper and lower bound\nconstraints are adjusted."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rxn_id"})," ",(0,s.jsx)(n.em,{children:"str"})," - The string representing the reaction identifier to change."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lower_bound"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The new value for the lower bound of the reaction (default is None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"upper_bound"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The new value for the upper bound of the reaction (default is None)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"change_enzyme_bounds",children:"change_enzyme_bounds"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def change_enzyme_bounds(enzyme_id: str,\n                         lower_bound: float = None,\n                         upper_bound: float = None)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Change the enzyme bounds. If the model should be primed for performing a sensitivity analysis,\nthe upper bound of the minimum and maximum enzyme concentration constraints are adjusted."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enzyme_id"})," ",(0,s.jsx)(n.em,{children:"str"})," - The string representing the enzyme identifier to change."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lower_bound"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The new value for the minimal enzyme concentration (default is None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"upper_bound"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The new value for the maximal enzyme concentration (default is None)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"get_enzymes_with_reaction_id",children:"get_enzymes_with_reaction_id"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def get_enzymes_with_reaction_id(rxn_id: str)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Return Enzyme objects associated with the reaction identifier through CatalyticEvent objects."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rxn_id"})," ",(0,s.jsx)(n.em,{children:"str"})," - The reaction identifier."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DictList"})," - A DictList of Enzyme objects associated with the reaction."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"get_reactions_with_enzyme_id",children:"get_reactions_with_enzyme_id"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def get_reactions_with_enzyme_id(enz_id: str)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Return a list of reaction identifiers associated with the enzyme identifier (EC number) through CatalyticEvent objects."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enz_id"})," ",(0,s.jsx)(n.em,{children:"str"})," - The enzyme identifier (EC number)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"List[str]"})," - A list of reaction identifiers associated with the enzyme."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"change_kcat_value",children:"change_kcat_value"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def change_kcat_value(enzyme_id: str, kcats: dict)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Change the turnover number (kcat) of the enzyme for a specific reaction."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enzyme_id"})," ",(0,s.jsx)(n.em,{children:"str"})," - The enzyme identifier."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"kcats"})," ",(0,s.jsx)(n.em,{children:"dict"})," - A dictionary with reaction identifiers as keys and kcat values as values.\nEach kcat value should be a nested dictionary with ",(0,s.jsx)(n.code,{children:"f"})," (forward) and ",(0,s.jsx)(n.code,{children:"b"})," (backward) as keys,\nand the corresponding kcat values as values."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["Example dictionary for the ",(0,s.jsx)(n.code,{children:"kcat"})," parameter"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"{'R1': {'f': 10.0, 'b': 5.0}, 'R2': {'f': 7.0, 'b': 3.0}}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"remove_enzymes",children:"remove_enzymes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def remove_enzymes(\n        enzymes: Union[str, Enzyme, List[Union[str, Enzyme]]]) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remove enzymes from the model."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enzymes"})," ",(0,s.jsx)(n.em,{children:"list, reaction, or str"})," - A list with enzymes (",(0,s.jsx)(n.code,{children:"Enzyme"}),"), or their IDs, to remove.\nEnzymes will be placed in a list. Strings will be placed in a list\nand used to find the enzymes in the model."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"The change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsx)(n.h4,{id:"remove_reactions",children:"remove_reactions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def remove_reactions(reactions: Union[str, Reaction, List[Union[str,\n                                                                Reaction]]],\n                     remove_orphans: bool = False) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remove reactions from the model. Inherited from the cobrapy.core.remove_reactions() function."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reactions"})," ",(0,s.jsx)(n.em,{children:"list, reaction, or str"})," - A list with reactions (",(0,s.jsx)(n.code,{children:"cobra.Reaction"}),"), or their IDs, to remove.\nReactions will be placed in a list. Strings will be placed in a list\nand used to find the reactions in the model."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"remove_orphans"})," ",(0,s.jsx)(n.em,{children:"bool, optional"})," - Remove orphaned genes and metabolites from the model as well (default False)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"The change is reverted upon exit when using the model as a context. Also removes associated CatalyticEvents if they exist."}),"\n",(0,s.jsx)(n.h4,{id:"remove_catalytic_events",children:"remove_catalytic_events"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def remove_catalytic_events(catalytic_events: Union[\n    str, CatalyticEvent, List[Union[str, CatalyticEvent]]],\n                            remove_orphans: bool = False) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remove catalytic events from the model."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reactions"})," ",(0,s.jsx)(n.em,{children:"list, reaction, or str"})," - A list with reactions (",(0,s.jsx)(n.code,{children:"cobra.Reaction"}),"), or their IDs, to remove.\nReactions will be placed in a list. Strings will be placed in a list\nand used to find the reactions in the model."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"remove_orphans"})," ",(0,s.jsx)(n.em,{children:"bool, optional"})," - Remove orphaned genes and metabolites from the model as well (default False)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"The change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsx)(n.h4,{id:"remove_sectors",children:"remove_sectors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def remove_sectors(\n    sectors: Union[\n        str,\n        Sector,\n        ActiveEnzymeSector,\n        List[Union[str, Sector, ActiveEnzymeSector]],\n    ]\n) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remove sections from the model."}),"\n",(0,s.jsx)(n.p,{children:"Also removes associated CatalyticEvents if they exist."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sectors"})," ",(0,s.jsx)(n.em,{children:"list, sector, or str"})," - A list with sector (",(0,s.jsx)(n.code,{children:"PAModelpy.Sector"})," or ",(0,s.jsx)(n.code,{children:"PAModelpy.ActiveEnzymeSector"}),"),\nor their IDs, to remove. A single sector will be placed in a list.\nStrings will be placed in a list and used to find the sector in the model."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"test",children:"test"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def test(glc_flux: Union[int, float] = 10)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Test the proteome allocation model."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"glc_flux"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The glucose flux which limits the growth rate (units: mmol_glc/g_cdw/h, default=10)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"pfba",children:"pfba"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def pfba(fraction_of_optimum: float = 1.0,\n         proteins: bool = False,\n         reactions: bool = True,\n         exclude: List["str"] = [],\n         objective: Union[Dict, "Objective", None] = None)\n'})}),"\n",(0,s.jsx)(n.p,{children:"Perform pFBA (parsimonious Enzyme Usage Flux Balance Analysis) with a custom objective including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"All reactions"}),"\n",(0,s.jsx)(n.li,{children:"All proteins"}),"\n",(0,s.jsx)(n.li,{children:"All proteins and all reactions."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"pFBA [1] adds the minimization of all fluxes to the objective of the model. This approach is motivated by the idea that high fluxes have a higher enzyme turnover, and since producing enzymes is costly, the cell will try to minimize overall flux while still maximizing the original objective function, e.g., the growth rate."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fraction_of_optimum"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The fraction of optimum which must be maintained. The original objective reaction is constrained to be greater than the maximal value times the ",(0,s.jsx)(n.code,{children:"fraction_of_optimum"})," (default 1.0)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"objective"})," ",(0,s.jsx)(n.em,{children:"dict or cobra.Model.objective, optional"})," - A desired objective to use during optimization in addition to the pFBA objective. Dictionaries (reaction as the key, coefficient as the value) can be used for linear objectives (default None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"proteins"})," ",(0,s.jsx)(n.em,{children:"bool, optional"})," - Determines whether to include enzyme variables in the pFBA objective."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reactions"})," ",(0,s.jsx)(n.em,{children:"bool, optional"})," - Determines whether to include reaction variables in the pFBA objective."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"exclude"})," ",(0,s.jsx)(n.em,{children:"list of reaction ids, optional"})," - Reactions to exclude from the minimization objective."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"References"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"[1] Lewis, N. E., Hixson, K. K., Conrad, T. M., Lerman, J. A., Charusanti, P., Polpitiya, A. D., Palsson, B. O. (2010). Omic data from evolved E. coli are consistent with computed optimal growth from genome-scale models. Molecular Systems Biology, 6, 390. doi:10.1038/msb.2010.47"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"reset_objective",children:"reset_objective"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def reset_objective()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Reseting the objective to the standard biomass maximization objective after pFBA"}),"\n",(0,s.jsx)(n.h4,{id:"optimize",children:"optimize"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def optimize(objective_sense: Optional[str] = None,\n             raise_error: bool = False) -> "Solution"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Optimize the model using flux balance analysis. Inherits from the cobra.Model.optimize() function and performs a sensitivity analysis after optimization if this is desired (by setting the PAModel.sensitivity attribute to True)."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"objective_sense"})," ",(0,s.jsxs)(n.em,{children:[(0,s.jsx)(n.code,{children:"{None, 'maximize', 'minimize'}"}),", optional"]})," - Whether fluxes should be maximized or minimized. In case of None, the previous direction is used (default None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"raise_error"})," ",(0,s.jsx)(n.em,{children:"bool"})," - If true, raise an OptimizationError if solver status is not optimal (default False)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Solution"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Only the most commonly used parameters are presented here. Additional parameters for cobra.solver may be available and specified with the appropriate keyword argument."}),"\n",(0,s.jsx)(n.h4,{id:"copy",children:"copy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def copy() -> "PAModel"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Provide a partial 'deepcopy' of the Model."}),"\n",(0,s.jsx)(n.p,{children:"Adjusted from cobra.Model.copy()."}),"\n",(0,s.jsx)(n.p,{children:"All the Metabolite, Gene, Reaction, Enzyme, EnzymeVariable, Sector, and CatalyticEvent objects are created anew but in a faster fashion than deepcopy."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PAModelpy.PAModel"})," - A new model copy."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);