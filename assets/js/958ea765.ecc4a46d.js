"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9266],{425:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>a});var s=i(5893),t=i(1151);const o={sidebar_label:"PAModel",title:"PAModel"},r=void 0,l={id:"api_reference/PAModel",title:"PAModel",description:"PAModel Objects",source:"@site/docs/api_reference/PAModel.md",sourceDirName:"api_reference",slug:"/api_reference/PAModel",permalink:"/PAModelpy/api_reference/PAModel",draft:!1,unlisted:!1,editUrl:"https://github.com/SamiralVdB/PAModelpy/tree/main/docs/docs/api_reference/PAModel.md",tags:[],version:"current",frontMatter:{sidebar_label:"PAModel",title:"PAModel"},sidebar:"tutorialSidebar",previous:{title:"PAMValidator",permalink:"/PAModelpy/api_reference/PAMValidator"},next:{title:"configuration",permalink:"/PAModelpy/api_reference/configuration"}},c={},a=[{value:"PAModel Objects",id:"pamodel-objects",level:2},{value:"P_TOT_DEFAULT",id:"p_tot_default",level:4},{value:"__init__",id:"__init__",level:4},{value:"add_enzymes",id:"add_enzymes",level:4},{value:"add_sectors",id:"add_sectors",level:4},{value:"add_sector",id:"add_sector",level:4},{value:"add_catalytic_events",id:"add_catalytic_events",level:4},{value:"add_enzyme_constraints",id:"add_enzyme_constraints",level:4},{value:"add_sector_constraints",id:"add_sector_constraints",level:4},{value:"add_total_protein_constraint",id:"add_total_protein_constraint",level:4},{value:"add_reactions",id:"add_reactions",level:4},{value:"add_lb_ub_constraints",id:"add_lb_ub_constraints",level:4},{value:"make_lb_ub_constraint",id:"make_lb_ub_constraint",level:4},{value:"make_enzyme_min_max_constraint",id:"make_enzyme_min_max_constraint",level:4},{value:"parse_shadow_prices",id:"parse_shadow_prices",level:4},{value:"calculate_csc",id:"calculate_csc",level:4},{value:"calculate_csc_for_molecule",id:"calculate_csc_for_molecule",level:4},{value:"calculate_enzyme_csc",id:"calculate_enzyme_csc",level:4},{value:"calculate_esc",id:"calculate_esc",level:4},{value:"calculate_sum_of_enzymes",id:"calculate_sum_of_enzymes",level:4},{value:"change_total_protein_constraint",id:"change_total_protein_constraint",level:4},{value:"change_reaction_bounds",id:"change_reaction_bounds",level:4},{value:"get_reaction_bounds",id:"get_reaction_bounds",level:4},{value:"change_enzyme_bounds",id:"change_enzyme_bounds",level:4},{value:"get_enzymes_with_reaction_id",id:"get_enzymes_with_reaction_id",level:4},{value:"get_reactions_with_enzyme_id",id:"get_reactions_with_enzyme_id",level:4},{value:"change_kcat_value",id:"change_kcat_value",level:4},{value:"remove_enzymes",id:"remove_enzymes",level:4},{value:"remove_enzyme_reaction_association",id:"remove_enzyme_reaction_association",level:4},{value:"remove_reactions",id:"remove_reactions",level:4},{value:"remove_catalytic_events",id:"remove_catalytic_events",level:4},{value:"remove_sectors",id:"remove_sectors",level:4},{value:"remove_active_enzymes_sector",id:"remove_active_enzymes_sector",level:4},{value:"remove_linear_sector",id:"remove_linear_sector",level:4},{value:"test",id:"test",level:4},{value:"pfba",id:"pfba",level:4},{value:"reset_objective",id:"reset_objective",level:4},{value:"optimize",id:"optimize",level:4},{value:"copy",id:"copy",level:4}];function d(e){const n={code:"code",em:"em",h2:"h2",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"pamodel-objects",children:"PAModel Objects"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class PAModel(Model)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Class representation for a cobra model extended with enzyme kinetics as published in Alter et al. (2021)."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"id_or_model"})," ",(0,s.jsx)(n.em,{children:"str or Model"})," - String to use as model id, or actual model to base new model on.\nIf a string, it is used as input to load a model from. If a model, a new model object is instantiated with\nthe same properties as the original model (default None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"})," ",(0,s.jsx)(n.em,{children:"str, optional"})," - Human-readable string to be model description (default None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"p_tot"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - Total protein concentration (condition-dependent) (unit g_prot/g_cdw) (default 0.285)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"senstitivity"})," ",(0,s.jsx)(n.em,{children:"bool"})," - Boolean value whether or not a sensitivity analysis should be performed during each simulation.\nThis sensitivity analysis will indicate to which extent individual constraints contribute to the objective value.\nEnzyme sectors (EnzymeSector objects, optional): Information about the different enzyme sectors, including:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Active_enzyme: Metabolic active proteins."}),"\n",(0,s.jsx)(n.li,{children:"Transl_enzyme: Enzymes related to translation."}),"\n",(0,s.jsx)(n.li,{children:"Unused_enzymes: Excess enzymes."}),"\n",(0,s.jsx)(n.li,{children:"Custom_enzymes (list): Custom enzyme sectors."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"configuration"})," ",(0,s.jsx)(n.em,{children:"Config object, optional"})," - Information about the general configuration of the model, including\nidentifier conventions. Default as defined in the ",(0,s.jsx)(n.code,{children:"PAModelpy.configuration"})," script for the E.coli iML1515 model."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Attributes"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"p_tot"})," ",(0,s.jsx)(n.em,{children:"float"})," - The fraction of biomass allocated to proteins (units: g_prot/g_cdw)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reactions"})," ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the reaction identifier and the value is a Reaction."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"metabolites"})," ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the metabolite identifier and the value is a Metabolite."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"genes"})," ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the gene identifier and the value is a Gene."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"0 ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the group identifier and the value is a Group."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"1 ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the enzyme identifier and the value is an Enzyme."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"2 ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the enzyme variable identifier and the value is an EnzymeVariable."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"3 ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the catalytic event identifier and the value is a CatalyticEvent."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"4 ",(0,s.jsx)(n.em,{children:"dict"})," - A dictionary containing sector-specific constraints."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),"5 ",(0,s.jsx)(n.em,{children:"DictList"})," - A DictList where the key is the sector identifier and the value is an EnzymeSector."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"p_tot_default",children:"P_TOT_DEFAULT"}),"\n",(0,s.jsx)(n.p,{children:"g_protein/g_cdw"}),"\n",(0,s.jsx)(n.h4,{id:"__init__",children:"__init__"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def __init__(id_or_model: Union[str, "Model", None] = None,\n             name: Optional[str] = None,\n             p_tot: Optional[float] = Config.P_TOT_DEFAULT,\n             sensitivity: bool = True,\n             active_sector: Optional[ActiveEnzymeSector] = None,\n             translational_sector: Optional[TransEnzymeSector] = None,\n             unused_sector: Optional[UnusedEnzymeSector] = None,\n             custom_sectors: Optional[CustomSector] = [None],\n             configuration=Config)\n'})}),"\n",(0,s.jsx)(n.p,{children:"Constants"}),"\n",(0,s.jsx)(n.h4,{id:"add_enzymes",children:"add_enzymes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_enzymes(enzyme_list: list) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Add new enzymes to a model.\nAdapted from Cobra.core.model.add_reactions and Cobra.core.model.add_metabolites."}),"\n",(0,s.jsx)(n.p,{children:"This function will add a DictList of enzymes to the model object and add new variables accordingly.\nFor each enzyme-associated reaction, a constraint in each direction is added to the model.\nThe change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enzyme_list"})," ",(0,s.jsx)(n.em,{children:"list or Enzyme"})," - A list of ",(0,s.jsx)(n.code,{children:"Enzyme"})," objects. If it isn't an iterable container, the enzyme will\nbe placed into a list."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_sectors",children:"add_sectors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_sectors(sectors: List = None)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Adds sector variables to the model and adds these to the total protein constraint."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sectors"})," ",(0,s.jsx)(n.em,{children:"list"})," - A list of PAModelpy.EnzymeSectors to add to the model."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_sector",children:"add_sector"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_sector(sector)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Adds the sector variable for a specific sector to the model and adds this to the total protein constraint.\nAlso stores the sector variables in the model attributes."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sector"})," ",(0,s.jsx)(n.em,{children:"PAModelpy.EnzymeSector"})," - The specific EnzymeSector to add to the model."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_catalytic_events",children:"add_catalytic_events"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_catalytic_events(catalytic_events: Optional[Iterable])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Add a new CatalyticEvent to the model.\nWill add a list of CatalyticEvent variables to the model object using the function defined in the CatalyticEvent object."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"catalytic_events"})," ",(0,s.jsx)(n.em,{children:"list or variables.CatalyticEvent"})," - A list of ",(0,s.jsx)(n.code,{children:"variables.CatalyticEvent"})," objects. If it isn't\nan iterable container, the catalytic event will be placed into a list."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_enzyme_constraints",children:"add_enzyme_constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_enzyme_constraints(constraint_list: Optional[list])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Add new enzyme constraints to a model.\nWill add a list of constraints to the model object and add new constraints accordingly.\nThe change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"constraint_list"})," ",(0,s.jsx)(n.em,{children:"list, str, or constraints.Constraint"})," - A list of ",(0,s.jsx)(n.code,{children:"constraints.Constraint"})," objects. If it isn't\nan iterable container, the constraint will be placed into a list. Also, a string with the constraint id\ncan be provided. A constraint will be created before adding it to the model."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_sector_constraints",children:"add_sector_constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_sector_constraints(constraint_list: Optional[list])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Add a new constraint related to a sector to a model.\nWill add a list of constraints to the model object and add new constraints accordingly.\nThe change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"constraint_list"})," ",(0,s.jsx)(n.em,{children:"list or constraints.Constraint"})," - A list of ",(0,s.jsx)(n.code,{children:"constraints.Constraint"})," objects. If it isn't an iterable\ncontainer, the constraint will be placed into a list."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_total_protein_constraint",children:"add_total_protein_constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_total_protein_constraint(p_tot: Optional[float] = P_TOT_DEFAULT)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Function which adds the total protein constraint to the model.\nThis limits the amount of available enzymes and thus the resulting fluxes."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"The constraint expression looks like this:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["``Etot",(0,s.jsx)(n.code,{children:" - sum(E) + E_translprot + E_unusedprot  == p_tot - E_trsn_0 - E_ue_0"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"p_tot"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - Fraction of biomass which consists of protein (g_protein/g_cdw).\nDefault is 0.258 (E.coli)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_reactions",children:"add_reactions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_reactions(reaction_list: Iterable[Reaction]) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Add reactions to the model.\nThis method is superimposed upon the cobra.Model.add_reactions() function.\nAs a new feature, it will add constraints to determine the lower and upper bound if a sensitivity analysis should\nbe performed (which is determined by the model attribute: PAModel.sensitivity).\nReactions with identifiers identical to a reaction already in the model are ignored.\nThe change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reaction_list"})," ",(0,s.jsx)(n.em,{children:"list"})," - A list of ",(0,s.jsx)(n.code,{children:"cobra.Reaction"})," objects."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"add_lb_ub_constraints",children:"add_lb_ub_constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def add_lb_ub_constraints()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Makes additional constraints for the reaction lower bounds and upperbounds.\nBy adding these constraints the shadow prices of the reaction bounds can be\ncalculated and used in sensitivity analysis"}),"\n",(0,s.jsx)(n.h4,{id:"make_lb_ub_constraint",children:"make_lb_ub_constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"@staticmethod\ndef make_lb_ub_constraint(m: Optional[Model], rxn: Reaction,\n                          lower_bound: float, upper_bound: float)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Adding variables and constraints for the lower and upper bounds of a reaction to a model.\nWhen solving the model, shadow prices for the lower and upper bounds will be calculated.\nThis allows for the calculation of sensitivity coefficients. The constraints are formulated as follows:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Constraints are formulated as follows:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"R_ub: R_fwd - R_rev <= UB"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"R_lb: -(R_fwd - R_rev) <= -LB"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"m"})," ",(0,s.jsx)(n.em,{children:"cobra.Model or PAModelpy.PAModel"})," - The model to which the upper and lower bound constraints and variables\nshould be added."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rxn"})," ",(0,s.jsx)(n.em,{children:"cobra.Reaction"})," - The reaction for which upper and lower bound constraints should be generated."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lower_bound"})," ",(0,s.jsx)(n.em,{children:"float"})," - The value of the lower bound."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"upper_bound"})," ",(0,s.jsx)(n.em,{children:"float"})," - The value of the upper bound."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"m"})," ",(0,s.jsx)(n.em,{children:"cobra.Model or PAModelpy.PAModel"})," - The model with additional constraints and variables for the reactions."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"make_enzyme_min_max_constraint",children:"make_enzyme_min_max_constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"@staticmethod\ndef make_enzyme_min_max_constraint(m: Optional[Model], enz: Enzyme,\n                                   lower_bound: float, upper_bound: float)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Adding variables and constraints for the lower and upperbounds of an Enzyme to a model.\nWhen solving the model, shadow prices for the lower and upperbounds will be calculated.\nThis allows for the calculation of sensitivity coefficients. The constraints are formulated as follows:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"The constraints are formulated as follows:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"enz_max : E <= Emax"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"enz_min : -E <= -Emin"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"m"})," ",(0,s.jsx)(n.em,{children:"cobra.Model or PAModelpy.PAModel"})," - The model to which the upper and lower bound constraints and variables\nshould be added."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rxn"})," ",(0,s.jsx)(n.em,{children:"PAModelpy.Enzyme"})," - The enzyme for which minimal and maximal concentration constraints should be generated."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lower_bound"})," ",(0,s.jsx)(n.em,{children:"float"})," - The value of the lower bound."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"upper_bound"})," ",(0,s.jsx)(n.em,{children:"float"})," - The value of the upper bound."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"m"})," ",(0,s.jsx)(n.em,{children:"cobra.Model or PAModelpy.PAModel"})," - The model with additional constraints and variables for the enzyme's\nconcentration."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"parse_shadow_prices",children:"parse_shadow_prices"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"@staticmethod\ndef parse_shadow_prices(shadow_prices)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Parse the shadow prices to a DataFrame where each constraint corresponds to a row, and shadow prices and directions are columns."}),"\n",(0,s.jsx)(n.h4,{id:"calculate_csc",children:"calculate_csc"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def calculate_csc(obj_value, mu, mu_ub, mu_lb, mu_ec_f, mu_ec_b)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Calculate the capacity sensitivity coefficient for all inequality constraints in the model.\nThe sum of all capacity sensitivity coefficients should equal 1 for growth maximization."}),"\n",(0,s.jsx)(n.p,{children:"Capacity Sensitivity Coefficient Calculation:\nCapacity Sensitivity Coefficient = constraint_UB * shadowprice / obj_value"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"obj_value"})," ",(0,s.jsx)(n.em,{children:"float"})," - The objective value of the model."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"mu"})," ",(0,s.jsx)(n.em,{children:"DataFrame"})," - Shadow prices for all constraints."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"mu_ub"})," ",(0,s.jsx)(n.em,{children:"DataFrame"})," - Shadow prices for the reaction upper bound (UB) constraints."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"mu_lb"})," ",(0,s.jsx)(n.em,{children:"DataFrame"})," - Shadow prices for the reaction lower bound (LB) constraints."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"mu_ec_f"})," ",(0,s.jsx)(n.em,{children:"DataFrame"})," - Shadow prices for the constraints related to enzymatic catalysis of the forward reaction."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"mu_ec_b"})," ",(0,s.jsx)(n.em,{children:"DataFrame"})," - Shadow prices for the constraints related to enzymatic catalysis of the backward reaction."]}),"\n",(0,s.jsx)(n.p,{children:"Results will be saved in the self.capacity_sensitivity_coefficients attribute as a dataframe"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"obj_value"})," - Float: optimal objective value, commonly maximal growth rate under specific conditions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu"})," - DataFrame: shadowprices for all constraints"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ub"})," - DataFrame: Shadowprices for the reaction UB constraints"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_lb"})," - DataFrame: Shadowprices for the reaction LB constraints"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ec_f"})," - DataFrame: Shadowprices for the constraint related to an enzymatic catalysis of the forward reaction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ec_b"})," - DataFrame: Shadowprices for the constraint related to an enzymatic catalysis of the backward reaction"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"calculate_csc_for_molecule",children:"calculate_csc_for_molecule"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def calculate_csc_for_molecule(molecule: Union[Enzyme], mu_min: pd.DataFrame,\n                               mu_max: pd.DataFrame, obj_value: float,\n                               constraint_type: str,\n                               associated_reactions: str)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Calculate the capacity sensitivity coefficients (CSCs) for constraints related to a biomolecule,\nsuch as enzymes. These coefficients reflect the effect of infitesmal changes in the constraint bounds\non the objective function."}),"\n",(0,s.jsx)(n.p,{children:"The coefficients and associated reactions will be saved in the capacity_sensitivity_coefficients dataframe."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enzyme:Enzyme"})," - enzyme object to calculate CSC for"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_min"})," - DataFrame: Shadowprices for the constraint related to a lower bound/minimum"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_max"})," - DataFrame: Shadowprices for the constraint related to an upper bound/maximum"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"obj_value"})," - float: optimal objective value, commonly maximal growth rate under specific conditions"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"calculate_enzyme_csc",children:"calculate_enzyme_csc"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def calculate_enzyme_csc(enzyme: Enzyme, mu_ec_f: pd.DataFrame,\n                         mu_ec_b: pd.DataFrame, obj_value: float)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Calculate the capacity sensitivity coefficients (CSCs) for constraints related to enzyme. These coefficients\nreflect the effect of infitesmal changes in the constraint bounds on the objective function. The coefficients\nand associated reactions will be saved in the capacity_sensitivity_coefficients dataframe."}),"\n",(0,s.jsx)(n.p,{children:"The function makes use of the abstracted function calculate_csc_for_molecule"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enzyme:Enzyme"})," - enzyme object to calculate CSC for"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ec_f"})," - DataFrame: Shadowprices for the constraint related to an enzymatic catalysis of the forward reaction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ec_b"})," - DataFrame: Shadowprices for the constraint related to an enzymatic catalysis of the backward reaction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"obj_value"})," - float: optimal objective value, commonly maximal growth rate under specific conditions"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"calculate_esc",children:"calculate_esc"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def calculate_esc(obj_value, mu_ec_f, mu_ec_b)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Calculate enzyme sensitivity coefficients for the enzyme variables using their primal values,\nthe objective value, and shadow prices according to the following relations:"}),"\n",(0,s.jsx)(n.p,{children:"Enzyme Sensitivity Coefficient Calculation:\nesc = enzyme_variable.primal * constraint.shadowprice / obj_value"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"obj_value"})," ",(0,s.jsx)(n.em,{children:"float"})," - The objective value from the most recent optimal solution."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ec_f"})," ",(0,s.jsx)(n.em,{children:"pd.DataFrame"})," - Shadow prices for maximizing enzyme concentrations (forward variables)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu_ec_b"})," ",(0,s.jsx)(n.em,{children:"pd.DataFrame"})," - Shadow prices for minimizing enzyme concentrations (reverse variables)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"None"}),"\n",(0,s.jsxs)(n.p,{children:["Fills the ",(0,s.jsx)(n.code,{children:"PAModel.enzyme_sensitivity_coefficients"})," dataframe with the calculated enzyme sensitivity coefficients."]}),"\n",(0,s.jsx)(n.h4,{id:"calculate_sum_of_enzymes",children:"calculate_sum_of_enzymes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def calculate_sum_of_enzymes()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Calculate the sum of all enzyme variables for a feasible solution."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"float"})," - The sum of all enzyme variables in milligrams per gram of cell dry weight per hour (mg/gCDW/h)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"change_total_protein_constraint",children:"change_total_protein_constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def change_total_protein_constraint(p_tot)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Change the fraction of biomass that is allocated to active proteins."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"p_tot"})," ",(0,s.jsx)(n.em,{children:"float"})," - The new proteome fraction in grams of protein per gram of cell dry weight (g_protein/g_cdw)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"change_reaction_bounds",children:"change_reaction_bounds"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def change_reaction_bounds(rxn_id: str,\n                           lower_bound: float = None,\n                           upper_bound: float = None)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Change the reaction bounds. If a sensitivity analysis is required, the bounds of the upper and lower bound\nconstraints are adjusted."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rxn_id"})," ",(0,s.jsx)(n.em,{children:"str"})," - The string representing the reaction identifier to change."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lower_bound"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The new value for the lower bound of the reaction (default is None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"upper_bound"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The new value for the upper bound of the reaction (default is None)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"get_reaction_bounds",children:"get_reaction_bounds"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def get_reaction_bounds(rxn_id: str) -> Tuple[Union[float, int]]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Get the reaction bounds. If there should be a sensitivity analysis, the bounds of the upper and lower bound\nconstraints returned"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rxn_id"})," - str\nstring of reaction id to return"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"change_enzyme_bounds",children:"change_enzyme_bounds"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def change_enzyme_bounds(enzyme_id: str,\n                         lower_bound: float = None,\n                         upper_bound: float = None)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Change the enzyme bounds. If the model should be primed for performing a sensitivity analysis,\nthe upper bound of the minimum and maximum enzyme concentration constraints are adjusted."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enzyme_id"})," ",(0,s.jsx)(n.em,{children:"str"})," - The string representing the enzyme identifier to change."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lower_bound"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The new value for the minimal enzyme concentration (default is None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"upper_bound"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The new value for the maximal enzyme concentration (default is None)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"get_enzymes_with_reaction_id",children:"get_enzymes_with_reaction_id"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def get_enzymes_with_reaction_id(rxn_id: str) -> DictList\n"})}),"\n",(0,s.jsx)(n.p,{children:"Return Enzyme objects associated with the reaction identifier through CatalyticEvent objects."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rxn_id"})," ",(0,s.jsx)(n.em,{children:"str"})," - The reaction identifier."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DictList"})," - A DictList of Enzyme objects associated with the reaction."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"get_reactions_with_enzyme_id",children:"get_reactions_with_enzyme_id"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def get_reactions_with_enzyme_id(enz_id: str)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Return a list of reaction identifiers associated with the enzyme identifier (EC number) through CatalyticEvent objects."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enz_id"})," ",(0,s.jsx)(n.em,{children:"str"})," - The enzyme identifier (EC number)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"List[str]"})," - A list of reaction identifiers associated with the enzyme."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"change_kcat_value",children:"change_kcat_value"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def change_kcat_value(enzyme_id: str, kcats: dict)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Change the turnover number (kcat) of the enzyme for a specific reaction."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enzyme_id"})," ",(0,s.jsx)(n.em,{children:"str"})," - The enzyme identifier."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"kcats"})," ",(0,s.jsx)(n.em,{children:"dict"})," - A dictionary with reaction identifiers as keys and kcat values as values.\nEach kcat value should be a nested dictionary with ",(0,s.jsx)(n.code,{children:"f"})," (forward) and ",(0,s.jsx)(n.code,{children:"b"})," (backward) as keys,\nand the corresponding kcat values as values."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["Example dictionary for the ",(0,s.jsx)(n.code,{children:"kcat"})," parameter"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"{'R1': {'f': 10.0, 'b': 5.0}, 'R2': {'f': 7.0, 'b': 3.0}}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"remove_enzymes",children:"remove_enzymes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def remove_enzymes(\n        enzymes: Union[str, Enzyme, List[Union[str, Enzyme]]]) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remove enzymes from the model."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enzymes"})," ",(0,s.jsx)(n.em,{children:"list, reaction, or str"})," - A list with enzymes (",(0,s.jsx)(n.code,{children:"Enzyme"}),"), or their IDs, to remove.\nEnzymes will be placed in a list. Strings will be placed in a list\nand used to find the enzymes in the model."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"The change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsx)(n.h4,{id:"remove_enzyme_reaction_association",children:"remove_enzyme_reaction_association"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def remove_enzyme_reaction_association(enzyme: Union[str, Enzyme],\n                                       reaction: Union[str, Reaction]) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remove an enzyme-reaction association from the model. Adapted from the cobra.core.remove_reactions() function.\nIf the reaction is not catalyzed by any enzyme anymore, the reaction ub will become 0"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"enzyme : Enzyme or str\nAn enzyme, or the enzyme id for which the association should be removed to remove.\nreaction : Reaction or str\nA reaction, or the reaction id for which the association should be removed to remove."}),"\n",(0,s.jsx)(n.h4,{id:"remove_reactions",children:"remove_reactions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def remove_reactions(reactions: Union[str, Reaction, List[Union[str,\n                                                                Reaction]]],\n                     remove_orphans: bool = False) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remove reactions from the model. Inherited from the cobrapy.core.remove_reactions() function."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reactions"})," ",(0,s.jsx)(n.em,{children:"list, reaction, or str"})," - A list with reactions (",(0,s.jsx)(n.code,{children:"cobra.Reaction"}),"), or their IDs, to remove.\nReactions will be placed in a list. Strings will be placed in a list\nand used to find the reactions in the model."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"remove_orphans"})," ",(0,s.jsx)(n.em,{children:"bool, optional"})," - Remove orphaned genes and metabolites from the model as well (default False)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"The change is reverted upon exit when using the model as a context. Also removes associated CatalyticEvents if they exist."}),"\n",(0,s.jsx)(n.h4,{id:"remove_catalytic_events",children:"remove_catalytic_events"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def remove_catalytic_events(catalytic_events: Union[\n    str, CatalyticEvent, List[Union[str, CatalyticEvent]]],\n                            remove_orphans: bool = False) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remove catalytic events from the model."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reactions"})," ",(0,s.jsx)(n.em,{children:"list, reaction, or str"})," - A list with reactions (",(0,s.jsx)(n.code,{children:"cobra.Reaction"}),"), or their IDs, to remove.\nReactions will be placed in a list. Strings will be placed in a list\nand used to find the reactions in the model."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"remove_orphans"})," ",(0,s.jsx)(n.em,{children:"bool, optional"})," - Remove orphaned genes and metabolites from the model as well (default False)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"The change is reverted upon exit when using the model as a context."}),"\n",(0,s.jsx)(n.h4,{id:"remove_sectors",children:"remove_sectors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def remove_sectors(\n    sectors: Union[\n        str,\n        Sector,\n        ActiveEnzymeSector,\n        List[Union[str, Sector, ActiveEnzymeSector]],\n    ]\n) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remove sections from the model."}),"\n",(0,s.jsx)(n.p,{children:"Also removes associated CatalyticEvents if they exist."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sectors"})," ",(0,s.jsx)(n.em,{children:"list, sector, or str"})," - A list with sector (",(0,s.jsx)(n.code,{children:"PAModelpy.Sector"})," or ",(0,s.jsx)(n.code,{children:"PAModelpy.ActiveEnzymeSector"}),"),\nor their IDs, to remove. A single sector will be placed in a list.\nStrings will be placed in a list and used to find the sector in the model."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"remove_active_enzymes_sector",children:"remove_active_enzymes_sector"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def remove_active_enzymes_sector(sector: ActiveEnzymeSector) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remove an active enzyme sector from the model."}),"\n",(0,s.jsx)(n.p,{children:"This function performs the following steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Removes all enzymes associated with the sector."}),"\n",(0,s.jsx)(n.li,{children:"Removes all catalytic events associated with the sector."}),"\n",(0,s.jsx)(n.li,{children:"If a total protein constraint exists, it removes this constraint."}),"\n",(0,s.jsx)(n.li,{children:"Deletes the sector constraint from the model's easy lookup."}),"\n",(0,s.jsx)(n.li,{children:"Removes the sector from the model and disconnects its link to the model."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sector"})," ",(0,s.jsx)(n.em,{children:"ActiveEnzymeSector"})," - The active enzyme sector to be removed."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"None"}),"\n",(0,s.jsx)(n.h4,{id:"remove_linear_sector",children:"remove_linear_sector"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def remove_linear_sector(\n    sector: Union[UnusedEnzymeSector, TransEnzymeSector,\n                  CustomSector]) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remove a linear sector from the model."}),"\n",(0,s.jsx)(n.p,{children:"This function performs the following steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"If a total protein constraint exists, it adjusts the constraint to remove the sector's contribution."}),"\n",(0,s.jsx)(n.li,{children:"Removes the associated constraints and variables."}),"\n",(0,s.jsx)(n.li,{children:"Deletes the sector constraint from the model's easy lookup."}),"\n",(0,s.jsx)(n.li,{children:"Removes the sector from the model and disconnects its link to the model."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sector"})," ",(0,s.jsx)(n.em,{children:"Union[UnusedEnzymeSector, TransEnzymeSector, CustomSector]"})," - The linear sector to be removed."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"None"}),"\n",(0,s.jsx)(n.h4,{id:"test",children:"test"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def test(glc_flux: Union[int, float] = 10)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Test the proteome allocation model."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"glc_flux"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The glucose flux which limits the growth rate (units: mmol_glc/g_cdw/h, default=10)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"pfba",children:"pfba"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def pfba(fraction_of_optimum: float = 1.0,\n         proteins: bool = False,\n         reactions: bool = True,\n         exclude: List["str"] = [],\n         objective: Union[Dict, "Objective", None] = None)\n'})}),"\n",(0,s.jsx)(n.p,{children:"Perform pFBA (parsimonious Enzyme Usage Flux Balance Analysis) with a custom objective including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"All reactions"}),"\n",(0,s.jsx)(n.li,{children:"All proteins"}),"\n",(0,s.jsx)(n.li,{children:"All proteins and all reactions."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"pFBA [1] adds the minimization of all fluxes to the objective of the model. This approach is motivated by the idea that high fluxes have a higher enzyme turnover, and since producing enzymes is costly, the cell will try to minimize overall flux while still maximizing the original objective function, e.g., the growth rate."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fraction_of_optimum"})," ",(0,s.jsx)(n.em,{children:"float, optional"})," - The fraction of optimum which must be maintained. The original objective reaction is constrained to be greater than the maximal value times the ",(0,s.jsx)(n.code,{children:"fraction_of_optimum"})," (default 1.0)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"objective"})," ",(0,s.jsx)(n.em,{children:"dict or cobra.Model.objective, optional"})," - A desired objective to use during optimization in addition to the pFBA objective. Dictionaries (reaction as the key, coefficient as the value) can be used for linear objectives (default None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"proteins"})," ",(0,s.jsx)(n.em,{children:"bool, optional"})," - Determines whether to include enzyme variables in the pFBA objective."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reactions"})," ",(0,s.jsx)(n.em,{children:"bool, optional"})," - Determines whether to include reaction variables in the pFBA objective."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"exclude"})," ",(0,s.jsx)(n.em,{children:"list of reaction ids, optional"})," - Reactions to exclude from the minimization objective."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"References"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"[1] Lewis, N. E., Hixson, K. K., Conrad, T. M., Lerman, J. A., Charusanti, P., Polpitiya, A. D., Palsson, B. O. (2010). Omic data from evolved E. coli are consistent with computed optimal growth from genome-scale models. Molecular Systems Biology, 6, 390. doi:10.1038/msb.2010.47"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"reset_objective",children:"reset_objective"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def reset_objective()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Reseting the objective to the standard biomass maximization objective after pFBA"}),"\n",(0,s.jsx)(n.h4,{id:"optimize",children:"optimize"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def optimize(objective_sense: Optional[str] = None,\n             raise_error: bool = False) -> "Solution"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Optimize the model using flux balance analysis. Inherits from the cobra.Model.optimize() function and performs a sensitivity analysis after optimization if this is desired (by setting the PAModel.sensitivity attribute to True)."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"objective_sense"})," ",(0,s.jsxs)(n.em,{children:[(0,s.jsx)(n.code,{children:"{None, 'maximize', 'minimize'}"}),", optional"]})," - Whether fluxes should be maximized or minimized. In case of None, the previous direction is used (default None)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"raise_error"})," ",(0,s.jsx)(n.em,{children:"bool"})," - If true, raise an OptimizationError if solver status is not optimal (default False)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Solution"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Only the most commonly used parameters are presented here. Additional parameters for cobra.solver may be available and specified with the appropriate keyword argument."}),"\n",(0,s.jsx)(n.h4,{id:"copy",children:"copy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def copy() -> "PAModel"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Provide a partial 'deepcopy' of the Model."}),"\n",(0,s.jsx)(n.p,{children:"Adjusted from cobra.Model.copy()."}),"\n",(0,s.jsx)(n.p,{children:"All the Metabolite, Gene, Reaction, Enzyme, EnzymeVariable, Sector, and CatalyticEvent objects are created anew but in a faster fashion than deepcopy."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PAModelpy.PAModel"})," - A new model copy."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);