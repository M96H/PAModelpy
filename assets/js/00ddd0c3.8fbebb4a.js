"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1225],{8828:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var i=t(5893),s=t(1151);const a={sidebar_label:"CatalyticEvent",title:"CatalyticEvent"},l=void 0,c={id:"api_reference/CatalyticEvent",title:"CatalyticEvent",description:"CatalyticEvent object which relates Reaction variables to the EnzymeVariable and Enzyme objects.",source:"@site/docs/api_reference/CatalyticEvent.md",sourceDirName:"api_reference",slug:"/api_reference/CatalyticEvent",permalink:"/PAModelpy/api_reference/CatalyticEvent",draft:!1,unlisted:!1,editUrl:"https://github.com/SamiralVdB/PAModelpy/tree/main/docs/docs/api_reference/CatalyticEvent.md",tags:[],version:"current",frontMatter:{sidebar_label:"CatalyticEvent",title:"CatalyticEvent"},sidebar:"tutorialSidebar",previous:{title:"API Reference",permalink:"/PAModelpy/category/api-reference"},next:{title:"Constraints",permalink:"/PAModelpy/api_reference/Constraints"}},r={},d=[{value:"CatalyticEvent Objects",id:"catalyticevent-objects",level:2},{value:"kcat_values",id:"kcat_values",level:4},{value:"flux",id:"flux",level:4},{value:"concentration",id:"concentration",level:4},{value:"add_enzymes",id:"add_enzymes",level:4},{value:"remove_enzymes",id:"remove_enzymes",level:4},{value:"change_kcat_values",id:"change_kcat_values",level:4},{value:"__copy__",id:"__copy__",level:4},{value:"__deepcopy__",id:"__deepcopy__",level:4}];function o(e){const n={code:"code",em:"em",h2:"h2",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"CatalyticEvent object which relates Reaction variables to the EnzymeVariable and Enzyme objects.\nIt contains multiple functions which enable easy mapping and handling of one Event of catalysis\n(e.g. one conversion of substrate to product, can be catalyzed by multiple enzymes)"}),"\n",(0,i.jsx)(n.h2,{id:"catalyticevent-objects",children:"CatalyticEvent Objects"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class CatalyticEvent(Object)\n"})}),"\n",(0,i.jsx)(n.p,{children:"CatalyticEvent is a class for holding information regarding the catalysis of a Reaction in a cobra.Model object.\nIt serves as an interface between the metabolic reaction and the associated enzyme constraints and variables."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"There are three different scenarios:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Enzyme complex: multiple enzymes together are associated with an EnzymeComplex object"}),"\n",(0,i.jsx)(n.li,{children:"Isozymes: multiple enzymes independently associated with a single catalytic event"}),"\n",(0,i.jsx)(n.li,{children:"Other: a single enzyme is associated with a single catalytic event"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"kcats2enzymes"})," ",(0,i.jsx)(n.em,{children:"dict"})," - A dictionary with enzyme, kcat key, value pairs to connect the enzyme with the associated reaction.\nThe kcat is another dictionary with 'f' and 'b' for the forward and backward reactions, respectively."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"id"})," ",(0,i.jsx)(n.em,{children:"str, optional"})," - The identifier to associate with this catalytic event (default None)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rxn_id"})," ",(0,i.jsx)(n.em,{children:"str, optional"})," - The reaction with which this catalytic event is associated."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"name"})," ",(0,i.jsx)(n.em,{children:"str, optional"}),' - A human-readable name for the reaction (default "").']}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"kcat_values",children:"kcat_values"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"@property\ndef kcat_values()\n"})}),"\n",(0,i.jsx)(n.p,{children:"returns a dictionary with kcat values and enzymes"}),"\n",(0,i.jsx)(n.h4,{id:"flux",children:"flux"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"@property\ndef flux() -> float\n"})}),"\n",(0,i.jsx)(n.p,{children:"Get the flux value in the most recent solution."}),"\n",(0,i.jsx)(n.p,{children:"Flux is the primal value of the corresponding variable in the model."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"flux"})," ",(0,i.jsx)(n.em,{children:"float"})," - Flux is the primal value of the corresponding variable in the model."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Warnings"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Accessing reaction fluxes through a ",(0,i.jsx)(n.code,{children:"Solution"})," object is the safer,\npreferred, and only guaranteed to be correct way. You can see how to\ndo so easily in the examples."]}),"\n",(0,i.jsxs)(n.li,{children:["Reaction flux is retrieved from the currently defined\n",(0,i.jsx)(n.code,{children:"self._model.solver"}),". The solver status is checked but there are no\nguarantees that the current solver state is the one you are looking\nfor."]}),"\n",(0,i.jsx)(n.li,{children:"If you modify the underlying model after an optimization, you will\nretrieve the old optimization values."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Raises"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RuntimeError"})," - If the underlying model was never optimized beforehand or the\nreaction is not part of a model."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"OptimizationError"})," - If the solver status is anything other than ",(0,i.jsx)(n.code,{children:"optimal"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"AssertionError"})," - If the flux value is not within the bounds."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Examples"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'>>> from cobra.io import load_model\n>>> model = load_model("textbook")\n>>> solution = model.optimize()\n>>> model.variables.PFK.flux\n7.477381962160283\n>>> solution.fluxes.PFK\n7.4773819621602833\n'})}),"\n",(0,i.jsx)(n.h4,{id:"concentration",children:"concentration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"@property\ndef concentration() -> float\n"})}),"\n",(0,i.jsx)(n.p,{children:"Get the enzyme concentration value of the most recent solution.\nThe enzyme concentration equals the flux value."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"float"})," - Enzyme concentration in [mmol/gDW]."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"add_enzymes",children:"add_enzymes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_enzymes(enzyme_kcat_dict: dict)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Add enzymes to the catalytic event and create bindings to the related model.\nThe enzymes in the enzyme_kcat_dict are individual isozymes. Enzyme complexes\nshould be added as an EnzymeComplex object with a single kcat value."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enzyme_kcat_dict"})," - Dict\nA nested dictionary with enzyme, kcat key, value pairs to connect the\nenzyme with the associated reaction. The kcat is another dictionary with ",(0,i.jsx)(n.code,{children:"f"})," and ",(0,i.jsx)(n.code,{children:"b"}),"\nfor the forward and backward reactions respectively."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"remove_enzymes",children:"remove_enzymes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def remove_enzymes(enzyme_list: list)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Remove enzymes from the catalytic event and remove the catalytic event from the\nconstraint expressions related to the enzyme."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enzyme_list"})," - List[Union[str, PAModelpy.Package.Enzyme]]\nA list with PAModelpy.Package.Enzyme objects to be removed. If a list of identifiers (str)\nis provided, the corresponding enzyme will be obtained from the CatalyticEvent.enzymes attribute."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"change_kcat_values",children:"change_kcat_values"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def change_kcat_values(enzyme_kcat_dict: dict)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Change kcat values for the enzyme variable."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enzyme_kcat_dict"})," - Dict[str, Dict[str, float]]\nA nested dictionary with enzyme identifiers as keys and kcat dictionaries as values.\nThe kcat dictionary should have ",(0,i.jsx)(n.code,{children:"f"})," and ",(0,i.jsx)(n.code,{children:"b"})," keys for the forward and backward reactions, respectively."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"__copy__",children:"__copy__"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def __copy__() -> "CatalyticEvent"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Copy the CatalyticEvent."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"CatalyticEvent:\nA new CatalyticEvent that is a copy of the original CatalyticEvent."}),"\n",(0,i.jsx)(n.h4,{id:"__deepcopy__",children:"__deepcopy__"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def __deepcopy__(memo: dict) -> "CatalyticEvent"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Copy the CatalyticEvent with memo."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"memo"})," ",(0,i.jsx)(n.em,{children:"dict"})," - Automatically passed parameter."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"CatalyticEvent:\nA new CatalyticEvent that is a copy of the original CatalyticEvent with memo."})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}}}]);