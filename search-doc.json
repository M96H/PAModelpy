{"searchDocs":[{"title":"Constraints","type":0,"sectionRef":"#","url":"/PAModelpy/api_reference/Constraints","content":"","keywords":"","version":"Next"},{"title":"Constraint Objects​","type":1,"pageTitle":"Constraints","url":"/PAModelpy/api_reference/Constraints#constraint-objects","content":" class Constraint(Metabolite)   Class for information about a Constraint in a protein Sector.  Constraint is a class for holding information similar to a metabolite in a cobra.Reaction object.  Arguments:  id str - The identifier to associate with the constraint.name str - A human-readable name. ","version":"Next","tagName":"h2"},{"title":"configuration","type":0,"sectionRef":"#","url":"/PAModelpy/api_reference/configuration","content":"","keywords":"","version":"Next"},{"title":"Config Objects​","type":1,"pageTitle":"configuration","url":"/PAModelpy/api_reference/configuration#config-objects","content":" class Config()   Object with information about model defaults which are used throughout the package:  TOTAL_PROTEIN_CONSTRAINT_ID: str, TotalProteinConstraintP_TOT_DEFAULT: float, 0.258 g_p/g_cdwCO2_EXHANGE_RXNID: str, EX_co2_eGLUCOSE_EXCHANGE_RXNID: str, EX_glc__D_eBIOMASS_REACTION: str, BIOMASS_Ec_iML1515_core_75p37MOXYGEN_UPTAKE_RXNID: str, EX_o2_eACETATE_EXCRETION_RXNID: str, EX_ac_ePHYS_RXN_IDS: List of str, [BIOMASS_REACTION, GLUCOSE_EXCHANGE_RXNID, ACETATE_EXCRETION_RXNID, CO2_EXHANGE_RXNID, OXYGEN_UPTAKE_RXNID, 'PGI', 'G6PDH2r', 'EDA', 'CS', 'ICL', 'PPC', 'ME1', 'ME2']  Defaults are configured for the iML1515 E.coli model  P_TOT_DEFAULT​  g_protein/g_cdw  reset​  def reset()   Reset the config object to the standard settings for E.coli iML1515. ","version":"Next","tagName":"h2"},{"title":"PAMValidator","type":0,"sectionRef":"#","url":"/PAModelpy/api_reference/PAMValidator","content":"","keywords":"","version":"Next"},{"title":"PAMValidator Objects​","type":1,"pageTitle":"PAMValidator","url":"/PAModelpy/api_reference/PAMValidator#pamvalidator-objects","content":" class PAMValidator(object)   MW_GLC​  g/mol  GRADIENT_MAX​  mmol/gdw/h  GRADIENT_STEP​  mmol/gdw/h  GRADIENT_MIN​  mmol/gdw/h  run_simulations_glc_o2_gradient​  def run_simulations_glc_o2_gradient( oxygen_gradient: list, params_to_save: Union[str, list] = &quot;R_TranslationalProteinSector&quot;)   Function to run simulations of different oxygen gradients for a range of growth rates.  This will simulate growth for the entire range of glucose concentrations for each oxygen uptake rate as given by the input.  Arguments:  oxygen_gradient list - List of upper bounds for the oxygen uptake reaction to loop over.params_to_save optional - string or list, which parameter(s) to save for further analysis (default: translational protein sector constraint).  Returns:  results list of dataframes - Saves the growth rate, glucose uptake rate, and the user-defined parameters for each oxygen uptake rate in separate dataframes.  run_simulations_ups​  def run_simulations_ups( ups_gradient: list, params_to_save: Union[str, list] = &quot;R_TranslationalProteinSector&quot;)   Function to run simulations with increasing unused enzyme sectors proportions for a range of growth rates.  This will simulate growth for the entire range of glucose concentrations for a range of fractions of ups_0 as given by the input.  Arguments:  ups_gradient list - List of upper bounds for the oxygen uptake reaction to loop over.params_to_save optional - string or list, which parameter(s) to save for further analysis (default: translational protein sector constraint).  Returns:  results list of dataframes - Saves the growth rate, glucose uptake rate, and the user-defined parameters for each oxygen uptake rate in separate dataframes.  custom_plot​  def custom_plot(rxn_ids: list, valid_dataframe: pd.DataFrame = None, xaxis: str = None, c_uptake_rxn: str = GLUCOSE_EXCHANGE_RXNID)   Function to plot the results of custom reactions.  Arguments:  rxn_ids list of str - Reaction identifiers of the reactions to be plotted.valid_dataframe pandas.DataFrame, optional - A DataFrame with experimental data to validate the results with. The columns should be the same as the rxn_id of the reaction to be plotted and the reaction which should be plotted on the x-axis (by default the glucose exchange reaction EX_glc__D_e_b). If the DataFrame is not provided, only the simulation results will be plotted.xaxis str, optional - The reaction identifier of the reaction which should be plotted on the x-axis (default: EX_glc__D_e_b).  Returns:  Prints scatter plots of the model simulations vs. experimental data points (if provided). ","version":"Next","tagName":"h2"},{"title":"EnzymeSectors","type":0,"sectionRef":"#","url":"/PAModelpy/api_reference/EnzymeSectors","content":"","keywords":"","version":"Next"},{"title":"Sector Objects​","type":1,"pageTitle":"EnzymeSectors","url":"/PAModelpy/api_reference/EnzymeSectors#sector-objects","content":" class Sector(Object)   __copy__​  def __copy__() -&gt; &quot;Sector&quot;   Copy the Sector.  Returns:  Sector - A new Sector that is a copy of the original Sector.  __deepcopy__​  def __deepcopy__(memo: dict) -&gt; &quot;Sector&quot;   Copy the Sector with memo.  Arguments:  memo dict - Automatically passed parameter.  Returns:  Sector - A new Sector that is a copy of the original Sector with memo.  ","version":"Next","tagName":"h2"},{"title":"EnzymeSector Objects​","type":1,"pageTitle":"EnzymeSectors","url":"/PAModelpy/api_reference/EnzymeSectors#enzymesector-objects","content":" class EnzymeSector(Sector)   DEFAULT_MOL_MASS​  mean enzymes mass E.coli [g/mol]  ","version":"Next","tagName":"h2"},{"title":"ActiveEnzymeSector Objects​","type":1,"pageTitle":"EnzymeSectors","url":"/PAModelpy/api_reference/EnzymeSectors#activeenzymesector-objects","content":" class ActiveEnzymeSector(Sector)   DEFAULT_MOL_MASS​  mean enzymes mass E.coli [g/mol]  __init__​  def __init__(rxn2protein: dict, configuration: Config = Config)   summary  Arguments:  rxn2protein dict - A dictionary with reaction ID, enzymes_dict key, value pairs for each reaction in the active_enzyme sector. The enzymes_dict contains the enzyme identifiers of the enzymes related to the specific reaction as keys, and a dict with information about the enzyme as values. The information included in this dict includes the turnover number for the forward and backward reaction (1/s), molar mass of the enzyme (mol/g), gene identifiers related to the enzyme, and with which other enzymes it forms a complex.configuration Config object, optional - Information about the general configuration of the model, including identifier conventions. Default is as defined in the PAModelpy.configuration script for the E.coli iML1515 model.  Example:  For the Parameter rxn2protein a dictionary may look like this: { 'R1': { 'E1': {'f': forward kcat, 'b': backward kcat, 'molmass': molar mass, 'genes': ['G1', 'G2'], 'complex_with': 'E2'}, 'E2': {'f': forward kcat, 'b': backward kcat, 'molmass': molar mass, 'genes': ['G3', 'G4'], 'complex_with': 'E1'} } }   check_kcat_values​  def check_kcat_values(model, reaction, kcat)   Function to check if the kcat values provided for an enzyme are consistent with the direction of the reaction.  Arguments:  model cobra.Model or PAModel - Model to which the kcat values should be added.reaction cobra.Reaction - Reaction that is catalyzed with the enzyme related to the kcats.kcat dict - A dictionary with the turnover values for the forward and/or backward reaction for different enzymes [/s].  Example:  Example dictionary for the kcat parameter  {'E1': {'f': forward kcat, 'b': backward kcat}}   ","version":"Next","tagName":"h2"},{"title":"TransEnzymeSector Objects​","type":1,"pageTitle":"EnzymeSectors","url":"/PAModelpy/api_reference/EnzymeSectors#transenzymesector-objects","content":" class TransEnzymeSector(EnzymeSector)   DEFAULT_MOL_MASS​  default E. coli ribosome molar mass [g/mol]  ","version":"Next","tagName":"h2"},{"title":"UnusedEnzymeSector Objects​","type":1,"pageTitle":"EnzymeSectors","url":"/PAModelpy/api_reference/EnzymeSectors#unusedenzymesector-objects","content":" class UnusedEnzymeSector(EnzymeSector)   DEFAULT_MOL_MASS​  mean enzymes mass E.coli [g/mol]  ","version":"Next","tagName":"h2"},{"title":"CustomSector Objects​","type":1,"pageTitle":"EnzymeSectors","url":"/PAModelpy/api_reference/EnzymeSectors#customsector-objects","content":" class CustomSector(EnzymeSector)   DEFAULT_ENZYME_MOL_MASS​  mean enzymes mass E.coli [g/mol] ","version":"Next","tagName":"h2"},{"title":"CatalyticEvent","type":0,"sectionRef":"#","url":"/PAModelpy/api_reference/CatalyticEvent","content":"","keywords":"","version":"Next"},{"title":"CatalyticEvent Objects​","type":1,"pageTitle":"CatalyticEvent","url":"/PAModelpy/api_reference/CatalyticEvent#catalyticevent-objects","content":" class CatalyticEvent(Object)   CatalyticEvent is a class for holding information regarding the catalysis of a Reaction in a cobra.Model object. It serves as an interface between the metabolic reaction and the associated enzyme constraints and variables.  Notes:  There are three different scenarios:  Enzyme complex: multiple enzymes together are associated with an EnzymeComplex objectIsozymes: multiple enzymes independently associated with a single catalytic eventOther: a single enzyme is associated with a single catalytic event  Arguments:  kcats2enzymes dict - A dictionary with enzyme, kcat key, value pairs to connect the enzyme with the associated reaction. The kcat is another dictionary with 'f' and 'b' for the forward and backward reactions, respectively.id str, optional - The identifier to associate with this catalytic event (default None).rxn_id str, optional - The reaction with which this catalytic event is associated.name str, optional - A human-readable name for the reaction (default &quot;&quot;).  kcat_values​  @property def kcat_values()   returns a dictionary with kcat values and enzymes  flux​  @property def flux() -&gt; float   Get the flux value in the most recent solution.  Flux is the primal value of the corresponding variable in the model.  Returns:  flux float - Flux is the primal value of the corresponding variable in the model.  Warnings:  Accessing reaction fluxes through a Solution object is the safer, preferred, and only guaranteed to be correct way. You can see how to do so easily in the examples.Reaction flux is retrieved from the currently definedself._model.solver. The solver status is checked but there are no guarantees that the current solver state is the one you are looking for.If you modify the underlying model after an optimization, you will retrieve the old optimization values.  Raises:  RuntimeError - If the underlying model was never optimized beforehand or the reaction is not part of a model.OptimizationError - If the solver status is anything other than optimal.AssertionError - If the flux value is not within the bounds.  Examples:  &gt;&gt;&gt; from cobra.io import load_model &gt;&gt;&gt; model = load_model(&quot;textbook&quot;) &gt;&gt;&gt; solution = model.optimize() &gt;&gt;&gt; model.variables.PFK.flux 7.477381962160283 &gt;&gt;&gt; solution.fluxes.PFK 7.4773819621602833   concentration​  @property def concentration() -&gt; float   Get the enzyme concentration value of the most recent solution. The enzyme concentration equals the flux value.  Returns:  float - Enzyme concentration in [mmol/gDW].  add_enzymes​  def add_enzymes(enzyme_kcat_dict: dict)   Add enzymes to the catalytic event and create bindings to the related model. The enzymes in the enzyme_kcat_dict are individual isozymes. Enzyme complexes should be added as an EnzymeComplex object with a single kcat value.  Arguments:  enzyme_kcat_dict - Dict A nested dictionary with enzyme, kcat key, value pairs to connect the enzyme with the associated reaction. The kcat is another dictionary with f and bfor the forward and backward reactions respectively.  remove_enzymes​  def remove_enzymes(enzyme_list: list)   Remove enzymes from the catalytic event and remove the catalytic event from the constraint expressions related to the enzyme.  Arguments:  enzyme_list - List[Union[str, PAModelpy.Package.Enzyme]] A list with PAModelpy.Package.Enzyme objects to be removed. If a list of identifiers (str) is provided, the corresponding enzyme will be obtained from the CatalyticEvent.enzymes attribute.  change_kcat_values​  def change_kcat_values(enzyme_kcat_dict: dict)   Change kcat values for the enzyme variable.  Arguments:  enzyme_kcat_dict - Dict[str, Dict[str, float]] A nested dictionary with enzyme identifiers as keys and kcat dictionaries as values. The kcat dictionary should have f and b keys for the forward and backward reactions, respectively.  __copy__​  def __copy__() -&gt; &quot;CatalyticEvent&quot;   Copy the CatalyticEvent.  Returns:  CatalyticEvent: A new CatalyticEvent that is a copy of the original CatalyticEvent.  __deepcopy__​  def __deepcopy__(memo: dict) -&gt; &quot;CatalyticEvent&quot;   Copy the CatalyticEvent with memo.  Arguments:  memo dict - Automatically passed parameter.  Returns:  CatalyticEvent: A new CatalyticEvent that is a copy of the original CatalyticEvent with memo. ","version":"Next","tagName":"h2"},{"title":"Enzyme","type":0,"sectionRef":"#","url":"/PAModelpy/api_reference/Enzyme","content":"","keywords":"","version":"Next"},{"title":"Enzyme Objects​","type":1,"pageTitle":"Enzyme","url":"/PAModelpy/api_reference/Enzyme#enzyme-objects","content":" class Enzyme(Object)   Upper level Enzyme object containing information about the enzyme and links to the EnzymeVariables for each reaction the enzyme catalyzes.  Arguments:  id (str): Identifier for the enzyme (e.g., Uniprot ID).rxn2kcat (Dict): Dictionary with reaction ID, kcat value pairs for the forward (f) and backward (b) reaction, e.g. {'PGI': {'f': 30, 'b': 0.1}}upper_bound (float): Upper bound for the enzyme variable (default 1000.0).lower_bound (float): Lower bound for the enzyme variable (default 0).name (str): Name of the enzyme (default None).molmass (float): Molar mass of the enzyme (default 3.947778784340140e04).  Notes:  This class is used to generate enzyme instances from kcat values and contains information about the forward as well as the backward catalysis.The enzyme is linked to individual cobra.Reaction variables with CatalyticEvent objects.There are two scenarios:Promiscuous enzymes: a single enzyme can catalyze multiple reactions.Other: a single enzyme catalyzes a single reaction.  DEFAULT_ENZYME_MOL_MASS​  mean enzymes mass E.coli [g/mol]  kcat_values​  @property def kcat_values()   Returns a dictionary with kcat values for each associated reaction.  Returns:  dict - A dictionary containing kcat values for associated reactions.  concentration​  @property def concentration(units: str = &quot;mmol/gDW&quot;, return_units: bool = False) -&gt; float   Returns the enzyme's total concentration considering any associated reactions.  Arguments:  units str, optional - Units in which the concentration is calculated (default is 'mmol/gDW'), other option is 'g/gDW'.return_units bool, optional - Determines whether the units should be returned as well.  Returns:  float - Enzyme concentration as a float.  add_catalytic_event​  def add_catalytic_event(ce: CatalyticEvent, kcats: Dict)   Adds a catalytic event associated with a reaction to an enzyme.  Arguments:  ce PAModelpy.Variables.CatalyticEvent - A CatalyticEvent object to which the enzyme should be added.kcats dict - A dictionary containing direction and kcat key-value pairs.  Returns:  NoneType - None  create_catalytic_event​  def create_catalytic_event(rxn_id: str, kcats: Dict)   Creates enzyme variables that link to reactions.  Arguments:  rxn_id str - ID of the associated reaction in the model.kcats Dict - A dictionary containing kcat values for the forward and backward reaction.  Returns:  Variables.CatalyticEvent - Enzyme variable object of type Variables.CatalyticEvent.  create_enzyme_variable​  def create_enzyme_variable()   Creates enzyme variables that link enzyme to reactions.  change_kcat_values​  def change_kcat_values(rxn2kcat: Dict)   Changes the kcat values for the enzyme and updates the enzyme variable (enzymatic reaction) accordingly.  Arguments:  rxn2kcat Dict - A dictionary with reaction ID, kcat value pairs for the forward (f) and backward (b) reaction, e.g. {'PGI': {'f': 30, 'b': 0.1}}  get_kcat_values​  def get_kcat_values(rxn_ids: Union[str, list] = None) -&gt; Dict   Returns the kcat values for a specific enzyme and all enzyme-associated reactions.  Arguments:  rxn_ids Union[str, list], optional - ID of the reactions for which the kcat values should be returned. It can be a single reaction ID (str) or a list of reaction IDs.  Returns:  Dict - A dictionary containing kcat values for the forward (f) and backward (b) reactions.  remove_catalytic_event​  def remove_catalytic_event(catalytic_event: Union[CatalyticEvent, str])   Function to remove a catalytic event from an enzyme.  Arguments:  catalytic_event Union[CatalyticEvent, str] - CatalyticEvent or str, catalytic event or identifier to remove.  __copy__​  def __copy__() -&gt; &quot;Enzyme&quot;   Copy the enzyme variable.  Returns:  PAModelpy.Enzyme.Enzyme - A new enzyme that is a copy of the original enzyme.  __deepcopy__​  def __deepcopy__(memo: dict) -&gt; &quot;Enzyme&quot;   Copy the enzyme variable with memo.  Arguments:  memo dict - Automatically passed parameter.  Returns:  PAModelpy.Enzyme.Enzyme - A new enzyme that is a copy of the original enzyme with memo.  ","version":"Next","tagName":"h2"},{"title":"EnzymeComplex Objects​","type":1,"pageTitle":"Enzyme","url":"/PAModelpy/api_reference/Enzyme#enzymecomplex-objects","content":" class EnzymeComplex(Enzyme)   Upper-level EnzymeComplex object containing information about the enzymes in a complex and a link to the enzyme variables (CatalyticEvents) for each reaction the enzyme complex catalyzes.  This class is used to generate enzyme instances from kcat values and contains information about the forward as well as the backward catalysis.  Arguments:  id str - Identifier for the enzyme complex (e.g., Uniprot ID).enzymes DictList of cobra.core.Enzyme - Enzyme objects associated with the enzyme complex.rxn2kcat Dict - Dictionary with reaction ID, kcat value pairs for the forward (f) and backward (b) reaction, e.g. {'PGI': {'f': 30, 'b': 0.1}}upper_bound float, optional - Upper bound for the enzyme variable (default 1000.0).name str, optional - Name of the enzyme (default None).molmass float, optional - Molar mass of the enzyme (default 3.947778784340140e04).  DEFAULT_ENZYME_MOL_MASS​  mean enzymes mass E.coli [g/mol]  ","version":"Next","tagName":"h2"},{"title":"EnzymeVariable Objects​","type":1,"pageTitle":"Enzyme","url":"/PAModelpy/api_reference/Enzyme#enzymevariable-objects","content":" class EnzymeVariable(Reaction)   EnzymeVariable is a class for holding information regarding the variable representing an enzyme in the model. For each reaction, the enzyme variables are summarized in a CatalyticEvent.  There are three different scenarios:  Enzyme complex: multiple enzymes together are associated with an EnzymeComplex object.Isozymes: multiple enzymes independently associated with a single catalytic event.Other: a single enzyme is associated with a single catalytic event.  Arguments:  kcats2rxns Dict - A dictionary with reaction_id, kcat key, value pairs to connect the enzyme with the associated reaction. The kcat is another dictionary with f and b for the forward and backward reactions, respectively.id str, optional - The identifier to associate with this enzyme (default None).name str, optional - A human-readable name for the enzyme (default &quot;&quot;).subsystem str, optional - Subsystem where the enzyme is meant to function (default &quot;&quot;).lower_bound float - The lower flux bound (default 0.0).upper_bound float, optional - The upper flux bound (default None).**kwargs - Additional keyword arguments are passed on to the parent class.  DEFAULT_ENZYME_MOL_MASS​  mean enzymes mass E.coli [g/mol]  kcat_values​  @property def kcat_values()   Returns a dictionary with kcat values and reactions.  Returns:  dict - A dictionary containing kcat values and their associated reactions.  flux​  @property def flux() -&gt; float   Get the flux value in the most recent solution.  Flux is the primal value of the corresponding variable in the model.  Returns:  float - Flux, which is the primal value of the corresponding variable in the model.  Raises:  RuntimeError - If the underlying model was never optimized beforehand or the reaction is not part of a model.OptimizationError - If the solver status is anything other than 'optimal'.AssertionError - If the flux value is not within the bounds.  Warnings:  Accessing reaction fluxes through a Solution object is the safer, preferred, and only guaranteed to be correct way.Reaction flux is retrieved from the currently defined self._model.solver. The solver status is checked but there are no guarantees that the current solver state is the one you are looking for.If you modify the underlying model after an optimization, you will retrieve the old optimization values.  Examples:  &gt;&gt;&gt; from cobra.io import load_model &gt;&gt;&gt; model = load_model(&quot;textbook&quot;) &gt;&gt;&gt; solution = model.optimize() &gt;&gt;&gt; model.variables.PFK.flux 7.477381962160283 &gt;&gt;&gt; solution.fluxes.PFK 7.4773819621602833   concentration​  @property def concentration() -&gt; float   Get the enzyme concentration value of the most recent solution.  The enzyme concentration equals the flux value.  Returns:  float - Enzyme concentration in mmol/gDW.  add_catalytic_events​  def add_catalytic_events(catalytic_events: list, kcats: list)   Adding catalytic events to an enzyme variable.  Arguments:  catalytic_events list - A list of catalytic events to add.kcats list - A list with dictionaries containing direction and kcat key-value pairs.  add_reactions​  def add_reactions(reaction_kcat_dict: dict)   Add reactions to the enzyme variable and create bindings to the related model. If there are multiple reactions related to a single enzyme, this is an isozyme.  Arguments:  reaction_kcat_dict dict - A nested dictionary with the reaction_id, kcat key, value pairs to connect the enzyme with the associated reaction. The kcat is another dictionary with f and b for the forward and backward reactions, respectively.  remove_catalytic_event​  def remove_catalytic_event(catalytic_event: Union[CatalyticEvent, str])   Remove a catalytic event from an enzyme.  Arguments:  catalytic_event Union[CatalyticEvent, str] - CatalyticEvent or str, catalytic event or identifier to remove.  remove_reactions​  def remove_reactions(reaction_list: list)   Remove reactions from the enzyme variable and remove the reactions from the constraint expressions related to the enzyme.  Arguments:  reaction_list list - A list with Cobra.Reaction objects which should be removed. If a list of identifiers (str) is provided, the corresponding enzyme will be obtained from the EnzymeVariables.reaction attribute.  change_kcat_values​  def change_kcat_values(reaction_kcat_dict: dict)   Changes kcat values for the enzyme variable.  Arguments:  reaction_kcat_dict dict - A nested dictionary with Cobra.Reaction, kcat key, value pairs to connect the enzyme with the associated reaction. The kcat is another dictionary with f and b for the forward and backward reactions, respectively.  __copy__​  def __copy__() -&gt; &quot;PAModelpy.Enzyme.EnzymeVariable&quot;   Copy the enzyme variable.  Returns:  PAModelpy.Enzyme.EnzymeVariable - A new enzyme variable that is a copy of the original enzyme variable.  __deepcopy__​  def __deepcopy__(memo: dict) -&gt; &quot;PAModelpy.Enzyme.EnzymeVariable&quot;   Copy the enzyme variable with memo.  Arguments:  memo dict - Automatically passed parameter.  Returns:  PAModelpy.Enzyme.EnzymeVariable - A new enzyme variable that is a copy of the original enzyme variable with memo. ","version":"Next","tagName":"h2"},{"title":"PAModel","type":0,"sectionRef":"#","url":"/PAModelpy/api_reference/PAModel","content":"","keywords":"","version":"Next"},{"title":"PAModel Objects​","type":1,"pageTitle":"PAModel","url":"/PAModelpy/api_reference/PAModel#pamodel-objects","content":" class PAModel(Model)   Class representation for a cobra model extended with enzyme kinetics as published in Alter et al. (2021).  Arguments:  id_or_model str or Model - String to use as model id, or actual model to base new model on. If a string, it is used as input to load a model from. If a model, a new model object is instantiated with the same properties as the original model (default None).name str, optional - Human-readable string to be model description (default None).p_tot float, optional - Total protein concentration (condition-dependent) (unit g_prot/g_cdw) (default 0.285).senstitivity bool - Boolean value whether or not a sensitivity analysis should be performed during each simulation. This sensitivity analysis will indicate to which extent individual constraints contribute to the objective value. Enzyme sectors (EnzymeSector objects, optional): Information about the different enzyme sectors, including: Active_enzyme: Metabolic active proteins.Transl_enzyme: Enzymes related to translation.Unused_enzymes: Excess enzymes.Custom_enzymes (list): Custom enzyme sectors. configuration Config object, optional - Information about the general configuration of the model, including identifier conventions. Default as defined in the PAModelpy.configuration script for the E.coli iML1515 model.  Attributes:  p_tot float - The fraction of biomass allocated to proteins (units: g_prot/g_cdw).reactions DictList - A DictList where the key is the reaction identifier and the value is a Reaction.metabolites DictList - A DictList where the key is the metabolite identifier and the value is a Metabolite.genes DictList - A DictList where the key is the gene identifier and the value is a Gene.name0 DictList - A DictList where the key is the group identifier and the value is a Group.name1 DictList - A DictList where the key is the enzyme identifier and the value is an Enzyme.name2 DictList - A DictList where the key is the enzyme variable identifier and the value is an EnzymeVariable.name3 DictList - A DictList where the key is the catalytic event identifier and the value is a CatalyticEvent.name4 dict - A dictionary containing sector-specific constraints.name5 DictList - A DictList where the key is the sector identifier and the value is an EnzymeSector.  P_TOT_DEFAULT​  g_protein/g_cdw  __init__​  def __init__(id_or_model: Union[str, &quot;Model&quot;, None] = None, name: Optional[str] = None, p_tot: Optional[float] = Config.P_TOT_DEFAULT, sensitivity: bool = True, active_sector: Optional[ActiveEnzymeSector] = None, translational_sector: Optional[TransEnzymeSector] = None, unused_sector: Optional[UnusedEnzymeSector] = None, custom_sectors: Union[List, CustomSector] = None, configuration=Config)   Constants  add_enzymes​  def add_enzymes(enzyme_list: list) -&gt; None   Add new enzymes to a model. Adapted from Cobra.core.model.add_reactions and Cobra.core.model.add_metabolites.  This function will add a DictList of enzymes to the model object and add new variables accordingly. For each enzyme-associated reaction, a constraint in each direction is added to the model. The change is reverted upon exit when using the model as a context.  Arguments:  enzyme_list list or Enzyme - A list of Enzyme objects. If it isn't an iterable container, the enzyme will be placed into a list.  add_sectors​  def add_sectors(sectors: List = None)   Adds sector variables to the model and adds these to the total protein constraint.  Arguments:  sectors list - A list of PAModelpy.EnzymeSectors to add to the model.  add_sector​  def add_sector(sector)   Adds the sector variable for a specific sector to the model and adds this to the total protein constraint. Also stores the sector variables in the model attributes.  Arguments:  sector PAModelpy.EnzymeSector - The specific EnzymeSector to add to the model.  add_catalytic_events​  def add_catalytic_events(catalytic_events: Optional[Iterable])   Add a new CatalyticEvent to the model. Will add a list of CatalyticEvent variables to the model object using the function defined in the CatalyticEvent object.  Arguments:  catalytic_events list or variables.CatalyticEvent - A list of variables.CatalyticEvent objects. If it isn't an iterable container, the catalytic event will be placed into a list.  add_enzyme_constraints​  def add_enzyme_constraints(constraint_list: Optional[list])   Add new enzyme constraints to a model. Will add a list of constraints to the model object and add new constraints accordingly. The change is reverted upon exit when using the model as a context.  Arguments:  constraint_list list, str, or constraints.Constraint - A list of constraints.Constraint objects. If it isn't an iterable container, the constraint will be placed into a list. Also, a string with the constraint id can be provided. A constraint will be created before adding it to the model.  add_sector_constraints​  def add_sector_constraints(constraint_list: Optional[list])   Add a new constraint related to a sector to a model. Will add a list of constraints to the model object and add new constraints accordingly. The change is reverted upon exit when using the model as a context.  Arguments:  constraint_list list or constraints.Constraint - A list of constraints.Constraint objects. If it isn't an iterable container, the constraint will be placed into a list.  add_total_protein_constraint​  def add_total_protein_constraint(p_tot: Optional[float] = P_TOT_DEFAULT)   Function which adds the total protein constraint to the model. This limits the amount of available enzymes and thus the resulting fluxes.  Notes:  The constraint expression looks like this:  ``Etot - sum(E) + E_translprot + E_unusedprot == p_tot - E_trsn_0 - E_ue_0  Arguments:  p_tot float, optional - Fraction of biomass which consists of protein (g_protein/g_cdw). Default is 0.258 (E.coli).  add_reactions​  def add_reactions(reaction_list: Iterable[Reaction]) -&gt; None   Add reactions to the model. This method is superimposed upon the cobra.Model.add_reactions() function. As a new feature, it will add constraints to determine the lower and upper bound if a sensitivity analysis should be performed (which is determined by the model attribute: PAModel.sensitivity). Reactions with identifiers identical to a reaction already in the model are ignored. The change is reverted upon exit when using the model as a context.  Arguments:  reaction_list list - A list of cobra.Reaction objects.  add_lb_ub_constraints​  def add_lb_ub_constraints()   Makes additional constraints for the reaction lower bounds and upperbounds. By adding these constraints the shadow prices of the reaction bounds can be calculated and used in sensitivity analysis  make_lb_ub_constraint​  @staticmethod def make_lb_ub_constraint(m: Optional[Model], rxn: Reaction, lower_bound: float, upper_bound: float)   Adding variables and constraints for the lower and upper bounds of a reaction to a model. When solving the model, shadow prices for the lower and upper bounds will be calculated. This allows for the calculation of sensitivity coefficients. The constraints are formulated as follows:  Notes:  Constraints are formulated as follows:  R_ub: R_fwd - R_rev &lt;= UBR_lb: -(R_fwd - R_rev) &lt;= -LB  Arguments:  m cobra.Model or PAModelpy.PAModel - The model to which the upper and lower bound constraints and variables should be added.rxn cobra.Reaction - The reaction for which upper and lower bound constraints should be generated.lower_bound float - The value of the lower bound.upper_bound float - The value of the upper bound.  Returns:  m cobra.Model or PAModelpy.PAModel - The model with additional constraints and variables for the reactions.  make_enzyme_min_max_constraint​  @staticmethod def make_enzyme_min_max_constraint(m: Optional[Model], enz: Enzyme, lower_bound: float, upper_bound: float)   Adding variables and constraints for the lower and upper bounds of an enzyme's concentration to a model. When solving the model, shadow prices for the lower and upper bounds will be calculated. This allows for the calculation of sensitivity coefficients.  Notes:  The constraints are formulated as follows:  E_ub: E &lt;= EmaxE_lb: -E &lt;= -Emin  Arguments:  m cobra.Model or PAModelpy.PAModel - The model to which the upper and lower bound constraints and variables should be added.rxn PAModelpy.Enzyme - The enzyme for which minimal and maximal concentration constraints should be generated.lower_bound float - The value of the lower bound.upper_bound float - The value of the upper bound.  Returns:  m cobra.Model or PAModelpy.PAModel - The model with additional constraints and variables for the enzyme's concentration.  parse_shadow_prices​  @staticmethod def parse_shadow_prices(shadow_prices)   Parse the shadow prices to a DataFrame where each constraint corresponds to a row, and shadow prices and directions are columns.  calculate_csc​  def calculate_csc(obj_value, mu, mu_ub, mu_lb, mu_ec_f, mu_ec_b)   Calculate the capacity sensitivity coefficient for all inequality constraints in the model. The sum of all capacity sensitivity coefficients should equal 1 for growth maximization.  Capacity Sensitivity Coefficient Calculation: Capacity Sensitivity Coefficient = constraint_UB * shadowprice / obj_value  Arguments:  obj_value float - The objective value of the model.mu DataFrame - Shadow prices for all constraints.mu_ub DataFrame - Shadow prices for the reaction upper bound (UB) constraints.mu_lb DataFrame - Shadow prices for the reaction lower bound (LB) constraints.mu_ec_f DataFrame - Shadow prices for the constraints related to enzymatic catalysis of the forward reaction.mu_ec_b DataFrame - Shadow prices for the constraints related to enzymatic catalysis of the backward reaction.  Returns:  None  Results are saved in the self.capacity_sensitivity_coefficients attribute as a DataFrame.  calculate_esc​  def calculate_esc(obj_value, mu_ec_f, mu_ec_b)   Calculate enzyme sensitivity coefficients for the enzyme variables using their primal values, the objective value, and shadow prices according to the following relations:  Enzyme Sensitivity Coefficient Calculation: esc = enzyme_variable.primal * constraint.shadowprice / obj_value  Arguments:  obj_value float - The objective value from the most recent optimal solution.mu_ec_f pd.DataFrame - Shadow prices for maximizing enzyme concentrations (forward variables).mu_ec_b pd.DataFrame - Shadow prices for minimizing enzyme concentrations (reverse variables).  Returns:  None  Fills the PAModel.enzyme_sensitivity_coefficients dataframe with the calculated enzyme sensitivity coefficients.  calculate_sum_of_enzymes​  def calculate_sum_of_enzymes()   Calculate the sum of all enzyme variables for a feasible solution.  Returns:  float - The sum of all enzyme variables in milligrams per gram of cell dry weight per hour (mg/gCDW/h).  change_total_protein_constraint​  def change_total_protein_constraint(p_tot)   Change the fraction of biomass that is allocated to active proteins.  Arguments:  p_tot float - The new proteome fraction in grams of protein per gram of cell dry weight (g_protein/g_cdw).  change_reaction_bounds​  def change_reaction_bounds(rxn_id: str, lower_bound: float = None, upper_bound: float = None)   Change the reaction bounds. If a sensitivity analysis is required, the bounds of the upper and lower bound constraints are adjusted.  Arguments:  rxn_id str - The string representing the reaction identifier to change.lower_bound float, optional - The new value for the lower bound of the reaction (default is None).upper_bound float, optional - The new value for the upper bound of the reaction (default is None).  change_enzyme_bounds​  def change_enzyme_bounds(enzyme_id: str, lower_bound: float = None, upper_bound: float = None)   Change the enzyme bounds. If the model should be primed for performing a sensitivity analysis, the upper bound of the minimum and maximum enzyme concentration constraints are adjusted.  Arguments:  enzyme_id str - The string representing the enzyme identifier to change.lower_bound float, optional - The new value for the minimal enzyme concentration (default is None).upper_bound float, optional - The new value for the maximal enzyme concentration (default is None).  get_enzymes_with_reaction_id​  def get_enzymes_with_reaction_id(rxn_id: str)   Return Enzyme objects associated with the reaction identifier through CatalyticEvent objects.  Arguments:  rxn_id str - The reaction identifier.  Returns:  DictList - A DictList of Enzyme objects associated with the reaction.  get_reactions_with_enzyme_id​  def get_reactions_with_enzyme_id(enz_id: str)   Return a list of reaction identifiers associated with the enzyme identifier (EC number) through CatalyticEvent objects.  Arguments:  enz_id str - The enzyme identifier (EC number).  Returns:  List[str] - A list of reaction identifiers associated with the enzyme.  change_kcat_value​  def change_kcat_value(enzyme_id: str, kcats: dict)   Change the turnover number (kcat) of the enzyme for a specific reaction.  Arguments:  enzyme_id str - The enzyme identifier.kcats dict - A dictionary with reaction identifiers as keys and kcat values as values. Each kcat value should be a nested dictionary with f (forward) and b (backward) as keys, and the corresponding kcat values as values.  Example:  Example dictionary for the kcat parameter  {'R1': {'f': 10.0, 'b': 5.0}, 'R2': {'f': 7.0, 'b': 3.0}}   remove_enzymes​  def remove_enzymes( enzymes: Union[str, Enzyme, List[Union[str, Enzyme]]]) -&gt; None   Remove enzymes from the model.  Arguments:  enzymes list, reaction, or str - A list with enzymes (Enzyme), or their IDs, to remove. Enzymes will be placed in a list. Strings will be placed in a list and used to find the enzymes in the model.  Notes:  The change is reverted upon exit when using the model as a context.  remove_reactions​  def remove_reactions(reactions: Union[str, Reaction, List[Union[str, Reaction]]], remove_orphans: bool = False) -&gt; None   Remove reactions from the model. Inherited from the cobrapy.core.remove_reactions() function.  Arguments:  reactions list, reaction, or str - A list with reactions (cobra.Reaction), or their IDs, to remove. Reactions will be placed in a list. Strings will be placed in a list and used to find the reactions in the model.remove_orphans bool, optional - Remove orphaned genes and metabolites from the model as well (default False).  Notes:  The change is reverted upon exit when using the model as a context. Also removes associated CatalyticEvents if they exist.  remove_catalytic_events​  def remove_catalytic_events(catalytic_events: Union[ str, CatalyticEvent, List[Union[str, CatalyticEvent]]], remove_orphans: bool = False) -&gt; None   Remove catalytic events from the model.  Arguments:  reactions list, reaction, or str - A list with reactions (cobra.Reaction), or their IDs, to remove. Reactions will be placed in a list. Strings will be placed in a list and used to find the reactions in the model.remove_orphans bool, optional - Remove orphaned genes and metabolites from the model as well (default False).  Notes:  The change is reverted upon exit when using the model as a context.  remove_sectors​  def remove_sectors( sectors: Union[ str, Sector, ActiveEnzymeSector, List[Union[str, Sector, ActiveEnzymeSector]], ] ) -&gt; None   Remove sections from the model.  Also removes associated CatalyticEvents if they exist.  Arguments:  sectors list, sector, or str - A list with sector (PAModelpy.Sector or PAModelpy.ActiveEnzymeSector), or their IDs, to remove. A single sector will be placed in a list. Strings will be placed in a list and used to find the sector in the model.  test​  def test(glc_flux: Union[int, float] = 10)   Test the proteome allocation model.  Arguments:  glc_flux float, optional - The glucose flux which limits the growth rate (units: mmol_glc/g_cdw/h, default=10).  pfba​  def pfba(fraction_of_optimum: float = 1.0, proteins: bool = False, reactions: bool = True, exclude: List[&quot;str&quot;] = [], objective: Union[Dict, &quot;Objective&quot;, None] = None)   Perform pFBA (parsimonious Enzyme Usage Flux Balance Analysis) with a custom objective including:  All reactionsAll proteinsAll proteins and all reactions.  pFBA [1] adds the minimization of all fluxes to the objective of the model. This approach is motivated by the idea that high fluxes have a higher enzyme turnover, and since producing enzymes is costly, the cell will try to minimize overall flux while still maximizing the original objective function, e.g., the growth rate.  Arguments:  fraction_of_optimum float, optional - The fraction of optimum which must be maintained. The original objective reaction is constrained to be greater than the maximal value times the fraction_of_optimum (default 1.0).objective dict or cobra.Model.objective, optional - A desired objective to use during optimization in addition to the pFBA objective. Dictionaries (reaction as the key, coefficient as the value) can be used for linear objectives (default None).proteins bool, optional - Determines whether to include enzyme variables in the pFBA objective.reactions bool, optional - Determines whether to include reaction variables in the pFBA objective.exclude list of reaction ids, optional - Reactions to exclude from the minimization objective.  References:  [1] Lewis, N. E., Hixson, K. K., Conrad, T. M., Lerman, J. A., Charusanti, P., Polpitiya, A. D., Palsson, B. O. (2010). Omic data from evolved E. coli are consistent with computed optimal growth from genome-scale models. Molecular Systems Biology, 6, 390. doi:10.1038/msb.2010.47  reset_objective​  def reset_objective()   Reseting the objective to the standard biomass maximization objective after pFBA  optimize​  def optimize(objective_sense: Optional[str] = None, raise_error: bool = False) -&gt; &quot;Solution&quot;   Optimize the model using flux balance analysis. Inherits from the cobra.Model.optimize() function and performs a sensitivity analysis after optimization if this is desired (by setting the PAModel.sensitivity attribute to True).  Arguments:  objective_sense {None, 'maximize', 'minimize'}, optional - Whether fluxes should be maximized or minimized. In case of None, the previous direction is used (default None).raise_error bool - If true, raise an OptimizationError if solver status is not optimal (default False).  Returns:  Solution  Notes:  Only the most commonly used parameters are presented here. Additional parameters for cobra.solver may be available and specified with the appropriate keyword argument.  copy​  def copy() -&gt; &quot;PAModel&quot;   Provide a partial 'deepcopy' of the Model.  Adjusted from cobra.Model.copy().  All the Metabolite, Gene, Reaction, Enzyme, EnzymeVariable, Sector, and CatalyticEvent objects are created anew but in a faster fashion than deepcopy.  Returns:  PAModelpy.PAModel - A new model copy. ","version":"Next","tagName":"h2"},{"title":"Example usage of PAModelpy","type":0,"sectionRef":"#","url":"/PAModelpy/example","content":"","keywords":"","version":"Next"},{"title":"Example 1: setting up an Escherichia coli Protein Allocation model (PAM)​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#example-1-setting-up-an-escherichia-coli-protein-allocation-model-pam","content":"   Escherichia coli (E.coli) is a commonly used model organism in Microbiology. When this microorganism is grown on increasing glucose concentration, it shifts from a purely respiratory metabolism to a respiro-fermentative metabolic phenotype. This phenomenon is called 'overflow metabolism'. Interestingly, overflow metabolism cannot be simulated using normal genome-scale models without additional constraints. With properly parametrized protein-constrained models however, we are able to simulate this metabolic phenotype. In this example, we'll set-up the E.coli PAM, and we'll study the predicted metabolic phenotypes for a range of glucose uptake rates.  For this entire tutorial, you'll need to load the following packages:  #importing the packages import os from cobra.io import read_sbml_model import pandas as pd #load PAMpy modules from PAModelpy.EnzymeSectors import ActiveEnzymeSector, TransEnzymeSector, UnusedEnzymeSector from PAModelpy.PAModel import PAModel from PAModelpy.PAMValidator import PAMValidator from PAModelpy.configuration import Config   ","version":"Next","tagName":"h2"},{"title":"Step 1: Initiate the protein sectors​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#step-1-initiate-the-protein-sectors","content":" Each protein-allocation model has three sectors: active enzyme sector (enzymes catalyzing the metabolic reactions), translational protein sectors (i.e. ribosomal proteins required for translation) and unused proteins (idle proteins which help the cell adapt to new conditions). The total of these three sectors is limited by an upperbound. This upperbound is determined by the sum of all non-maintenance enzymes, which is assumed to be constant for prokaryotes. For examples on how to parametrize these sectors, refer to Scripts/create_ecolicore_pam_inclUE.ipynb.  1.1: Active enzyme sector​  The active enzyme sector will be build using information about which enzymes catalyzes a specific reaction, the turnover rate of the catalysis and the molar mass of the enzyme. In this example we'll use the parameters as published by Alter et al. (2021), which can be found in the Data folder of the PAModelpy repository  First, we'll define the paths we'll download the data  protein_sector_info_path = 'Data/proteinAllocationModel_iML1515_EnzymaticData_py.xls' active_enzyme_data = pd.read_excel(protein_sector_info_path, sheet_name='ActiveEnzymes'))   The data is now in a dataframe with the following columns:rxn_id - rxnName - rxnEquat - EC_nmbr - molMassFirst, let's add an identifier to the reactions for which the enzyme is unknown, in order to distinguish between the enzymes  #load active enzyme sector information active_enzyme_info = pd.read_excel(pam_info_file, sheet_name='ActiveEnzymes') # replace NaN values with unique identifiers #select the NaN values nan_values = active_enzyme_info['EC_nmbr'].isnull() #make a list with unique ids nan_ids = [f'E{i}' for i in range(nan_values.sum())] #replace nan values by unique id active_enzyme_info.loc[nan_values, 'EC_nmbr'] = nan_ids #check if it worked: active_enzyme_info[nan_values]   We need to collect the data from this table and put it in the correct structure to be parsed into the ActiveEnzymeSector object. The main input in this object is the rxn2protein dictionary, where all the information about protein-reaction associations required to build the protein-reaction relations in the model. It has the following format:  {'R1': {'E1': {'f': forward kcat, 'b': backward kcat, 'molmass': molar mass}, 'E2': {'f': forward kcat, 'b': backward kcat, 'molmass': molar mass} } }   We need to take the following steps to get the right format:  # parse the enzyme information (kcat values, identifiers and molmasses) kcats_dict = active_enzyme_info.set_index(keys='rxnID').loc[:, 'kcat'].to_dict() ec_dict = active_enzyme_info.set_index(keys='rxnID').loc[:, 'EC_nmbr'].to_dict() molmass_dict = mol_mass=active_enzyme_info.set_index(keys='rxnID').loc[:,'molMass'].to_dict() kcats = {} # save fwd and bckw kcats separately in the form of: {rxn_id: {'f': kcat_f, 'b': kcat_b}} for rxn, kcat in kcats_dict.items(): #reversible reaction if rxn[-2:] == '_f' or rxn[-2:] == '_b': direction = rxn[-1] #check if the reaction already exists in the kcat dictionary try: kcats[rxn[:-2]][direction] = kcat except: kcats[rxn[:-2]] = {direction: kcat} #irreversible reaction else: kcats[rxn] = {'f': kcat} rxn2ec = {} #parse the enzyme identifiers for the reactions for rxn, ec in ec_dict.items(): if rxn[-2:] == '_f' or rxn[-2:] == '_b': rxn = rxn[:-2] for enz in str(ec).split(','): rxn2ec[rxn] = enz.strip() molmass = {} #parse the enzyme molmasses for the reactions for rxn, mw in molmass_dict.items(): if rxn[-2:] == '_f' or rxn[-2:] == '_b': rxn = rxn[:-2] molmass[rxn] = mw rxn2protein = {} for rxn, ec in rxn2ec.items(): ec_dict = {**kcats[rxn], **{'molmass': molmass[rxn]}} #add enzyme to enzymes related to reaction if these are already stored if rxn in rxn2protein.keys(): rxn2protein[rxn] = {**rxn2protein[rxn], **{ec:ec_dict}} #if not create new reaction entry else: rxn2protein[rxn] = {ec:ec_dict} active_enzyme_sector = ActiveEnzymeSector(rxn2protein=rxn2protein)   1.2: Translational protein sector​  The translational sector requires less parameters. We only need to define the reaction to which this section is proportional, (for example the biomass pseudoreaction or substrate uptake rate), defined by id_list, and the slope (tps_mu) and intercept (tps_0) of this relation.  translational_info = pd.read_excel(protein_sector_info_path, sheet_name='Translational') id_list = [translational_info[translational_info.Parameter == 'id_list'].loc[0,'Value']] translation_enzyme_sector = TransEnzymeSector(id_list=id_list, tps_0=[translational_info[translational_info.Parameter == 'tps_0'].loc[1,'Value']], tps_mu=[translational_info[translational_info.Parameter == 'tps_mu'].loc[2,'Value']], mol_mass=[translational_info[translational_info.Parameter == 'mol_mass'].loc[3,'Value']])   1.3 Unused enzyme sector​  The unused enzyme sector is defined in a very similar way as the translational protein sector. We assume that this section is absent when the microbe is growing at it's highest growth rate. We'll use this assumption to define the slope:  unused_protein_info = pd.read_excel(pam_info_file, sheet_name='ExcessEnzymes') ups_0 = unused_protein_info[unused_protein_info.Parameter == 'ups_0'].loc[2,'Value'] smax = unused_protein_info[unused_protein_info.Parameter == 's_max_uptake'].loc[1,'Value'] id_list =[unused_protein_info[translational_info.Parameter == 'id_list'].loc[0,'Value']] unused_protein_sector = UnusedEnzymeSector(id_list=id_list, ups_mu=[ups_0/smax], ups_0=[ups_0], mol_mass=[unused_protein_info[unused_protein_info.Parameter == 'mol_mass'].loc[3,'Value']])   ","version":"Next","tagName":"h3"},{"title":"Step 2: Building the model​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#step-2-building-the-model","content":" Now we are ready to build the model! We'll need to determine a maximal protein concentration. Following Alter et al. (2021), let's take 0.258 mmol/gcdw/h. As a basis, we'll use the iML1515 model, created by Monk et al. (2017).  NB: for the more advanced users who want to run the sensitivity analysis, please ensure that the sensitivity argument is set to True. If you are not interested in the sensitivity analysis, you can set sensitivity to False, which will speed up the computation time.  #load the genome-scale information model = read_sbml_model(os.path.join('Models', 'iML1515.xml')) #load the PAM with the genome-scale information and the information about the enzyme sectors pamodel = PAModel(id_or_model=model, p_tot=0.258, active_sector=active_enzyme_sector, translational_sector=translation_enzyme_sector, unused_sector=unused_protein_sector, sensitivity =True )   ","version":"Next","tagName":"h3"},{"title":"Step 3: run and validate the model results​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#step-3-run-and-validate-the-model-results","content":" To see if the PAM is working we can run some dummy simulations. Also, the PAMValidator module has functions which allow for easy visualization of the model predictions vs measured experimental data.  pamodel.test()   This is a simulation with a glucose uptake rate set to 10 mmol/gcdw/h. We can easily change to a different substrate uptake rate, e.g. 5 mmol/gcdw/h by putting that in as an function argument  pamodel.test(5)   In the PAMValidator object, you can find functions to run simulations over a range of substrate uptake rates. To initiate the PAMValidator, you need to provide the model and a path to an excel file with experimental data. In this example,we'll use the experimental data which can be found inData/Ecoli_phenotypes/Ecoli_phenotypes_py_rev.xls.  from PAModelpy.PAMValidator import PAMValidator validator = PAMValidator(pamodel,'Data/Ecoli_phenotypes/Ecoli_phenotypes_py_rev.xls') #model flux rates of biomass formation, acetate, CO2 and O2 vs glucose uptake rate for a range of growth rates validator.validate_range()   Alternatively, you can run simulations in a good old-fashioned for-loop. For examples on how to do that look at the jupyter notebooks in the Figures directory.  ","version":"Next","tagName":"h3"},{"title":"Step 4: interpreting the results​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#step-4-interpreting-the-results","content":" What does the result tell you? What is the predicted metabolic phenotype and how does this relate to the experimental results. Did the model capture overflow metabolism?  ","version":"Next","tagName":"h3"},{"title":"Outlook​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#outlook","content":" After this tutorial, you know how to apply PAModelpy to this very well-studied E.coli example. But how to address you're specific issue with your specific microbe? In the next example we'll show you how to use the Config() object to give the PAModel the right naming conventions for your specific microbe. Are you more interested in performing modifications to the model, such as deleting or adding enzymes, changing kcats, changing enzymes upper- and lowerbounds? Then have a look at the following jupyter notebook: Examples/PAModel_example_script.ipynb. Have fun!  ","version":"Next","tagName":"h3"},{"title":"Example 2: Determining the most sensitive enzymes in a toy model​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#example-2-determining-the-most-sensitive-enzymes-in-a-toy-model","content":"   When looking at the flux distribution resulting from our simulations, we do not get any information about which enzymes played an important role in prediciting the specific metabolic phenotype. However, with the right model configurations, we get the sensitivity of the objective function to slight changes in the enzyme availability (enzyme sensitivity coefficients, ESC) as a result from the model simulations. In this example we'll use a toy model to illustrate how these sensitivities can help us explain concepts of protein allocation.  Figure 1. Toy model network and parameters This toy model represents a schematic overview of a microbial metabolism, with an energy efficient (R1-R2-R4+R5-R6-R7) and an enzyme efficient (R1-R2-R3+R5-R6-R7) pathway. Besides the enzymes catalyzing the reactions (denoted with an 'E') and corresponding catalytic efficiency (kcat), also the relation with the reactions and the enzyme sectors are given. UES: Unused Enzyme Sector, TES: Translational Enzyme Sector, AES: Active Enzyme Sector.  First, all import statements you'll need in this example:  import numpy as np from cobra.io import load_json_model import plotly.express from PAModelpy.EnzymeSectors import ActiveEnzymeSector, TransEnzymeSector, UnusedEnzymeSector from PAModelpy.PAModel import PAModel from PAModelpy.PAMValidator import PAMValidator from PAModelpy.configuration import Config   ","version":"Next","tagName":"h2"},{"title":"Step 1: Build the toy model​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#step-1-build-the-toy-model","content":" Obviously, we first have to build the toy model. To make it easy, we have provided the toy model structure in a .json file in the Models directory. As the PAModelpy package makes working with real-life data easy, it performs units conversions to some inputs. For example, the kcat value is normally published in per sec, while we need per hour in our calculations. Furthermore, some inputs are scaled in order to decrease the order of magnitude difference between the variables. When we want to use 'dummy' data in a toy model, we need to take this into account.  But before we start building the model, we need to be aware of one thing: the PAModel object assumes you want to analyse the E.coli iML1515 model by default. How can we make the model aware that we are using another model, and that we thus need other identifiers for substrate uptake rate, growth rate, etc? The Config object helps you with just that! You can use this object to configure all the identifiers you need. Don't forget to pass this object to all the PAModel objects you'll initialize, so all the information is passed on!  config = Config() config.BIOMASS_REACTION = 'R7' config.GLUCOSE_EXCHANGE_RXNID = 'R1' config.CO2_EXHANGE_RXNID = 'R8' config.ACETATE_EXCRETION_RXNID = 'R9'   With these defaults defined, we can start building our model.  nmbr_reactions = 9 # Building Active Enzyme Sector kcat_fwd = [1, 0.5, 1, 1, 0.5 ,0.45, 1.5] kcat_rev = [kcat for kcat in kcat_fwd] rxn2kcat = {} for i in range(nmbr_reactions-3): # all reactions have an enzyme, except excretion reactions rxn_id = f'R{i+1}' # 1e-6 to correct for the unit transformation in the model (meant to make the calculations preciser for different unit dimensions) #dummy molmass rxn2kcat = {**rxn2kcat, **{rxn_id: {f'E{i+1}':{'f': kcat_fwd[i]/(3600*1e-6), 'b': kcat_rev[i]/(3600*1e-6), 'molmass': 1e6}}}} active_enzyme = ActiveEnzymeSector(rxn2protein = rxn2kcat, configuration=config) # Building Tranlational Protein Sector translation_enzyme = TransEnzymeSector(id_list = ['R7'], tps_mu=[0.01*1e-3], tps_0=[0.01*1e-3], mol_mass= [1], configuration=config) # Building Unused Enzyme Sector unused_enzyme = UnusedEnzymeSector(id_list = ['R1'], ups_mu=[-0.01*1e-3], ups_0=[0.1*1e-3], mol_mass= [1], configuration=config) # Building the toy_pam model = load_json_model('Models/toy_model.json') toy_pam = PAModel(model, name='toy model MCA with enzyme constraints', active_sector=active_enzyme, translational_sector = translation_enzyme, unused_sector = unused_enzyme, p_tot=0.6*1e-3, configuration=config)   ","version":"Next","tagName":"h3"},{"title":"Step 2: Perform the model simulations​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#step-2-perform-the-model-simulations","content":" With the model in place, we can start our analysis. Since we are interested in which enzymes are important in different metabolic phenotypes, we want to run simulations over a range of growth rates. After each simulation we need to retrieve and store the enzyme sensitivity coefficients, so we can study them. We also will save the capacity sensitivity coefficients, which will give us information about which factor is limiting metabolism (substrate or enzyme availability). We directly save all the information we need later for plotting.  substrate_axis = list() Ccsc = list() Cesc = list() x_axis_csc = list() mu_list = list() for substrate in list(np.arange(1e-3, 1e-1, 1e-2)): toy_pam.change_reaction_bounds(rxn_id='R1', lower_bound=0, upper_bound=substrate) toy_pam.optimize() if toy_pam.solver.status == 'optimal' and toy_pam.objective.value&gt;0: print('Running simulations with ', substrate, 'mmol/g_cdw/h of substrate going into the system') substrate_axis += [substrate] mu_list += [toy_pam.objective.value] Ccsc_new = list() for csc in ['flux_ub', 'flux_lb', 'enzyme_max', 'enzyme_min', 'proteome', 'sector']: Ccsc_new += toy_pam.capacity_sensitivity_coefficients[toy_pam.capacity_sensitivity_coefficients['constraint'] == csc].coefficient.to_list() Ccsc += [Ccsc_new] Cesc += [toy_pam.enzyme_sensitivity_coefficients.coefficient.to_list()] print('Sum of capacity sensitivity coefficients: \\t \\t \\t \\t \\t \\t \\t ', round(sum(Ccsc_new),6)) print('Sum of variable sensitivity coefficients: \\t \\t \\t \\t \\t \\t \\t ', round(sum(Cesc[-1]), 6), '\\n') for csc in ['flux_ub', 'flux_lb', 'enzyme_max', 'enzyme_min', 'proteome', 'sector']: if csc == 'flux_ub' or csc == 'flux_lb': x_axis_csc += [rid +'_' + csc for rid in toy_pam.capacity_sensitivity_coefficients[toy_pam.capacity_sensitivity_coefficients['constraint'] == csc].rxn_id.to_list()] else: x_axis_csc += [rid +'_' + csc for rid in toy_pam.capacity_sensitivity_coefficients[toy_pam.capacity_sensitivity_coefficients['constraint'] == csc].enzyme_id.to_list()] x_axis_esc = toy_pam.enzyme_sensitivity_coefficients.enzyme_id.to_list()   ","version":"Next","tagName":"h3"},{"title":"Step 3: Plot the enzyme and capacity sensitivty coefficients heatmaps​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#step-3-plot-the-enzyme-and-capacity-sensitivty-coefficients-heatmaps","content":" By plotting our results, we learn which individual reactions and enzymes contribute the most to which metabolic phenotype.  def print_heatmap(xaxis, matrix, yaxis = None): if yaxis is None: yaxis = list() for i in range(1, n + 1): yaxis += [f'R{i}'] fig = plotly.express.imshow(matrix, aspect=&quot;auto&quot;, x = xaxis, y = yaxis, labels = dict(x = 'sensitivity coefficients', y='substrate uptake')) fig.show() print_heatmap(x_axis_csc, Ccsc, yaxis=substrate_axis) print_heatmap(x_axis_esc, Cesc, yaxis=substrate_axis)   ","version":"Next","tagName":"h3"},{"title":"Step 4: Interpret the results​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#step-4-interpret-the-results","content":" Compare the toy model network structure with the results from the heatmap. Did you expect these results? Do they make sense? Which mechanisms to explain these observations. If the observations are not inline with you're expectations, you can use the enzyme sensitivities to point to the enzymatic parameters which might need to be adjusted (in this dummy example this makes no sense off course, but in reality this is a very plausible outcome).  ","version":"Next","tagName":"h3"},{"title":"Outlook​","type":1,"pageTitle":"Example usage of PAModelpy","url":"/PAModelpy/example#outlook-1","content":" This tastes like more? In our publication we use the sensitivity analysis to explain metabolic phenotypes and to pinpoint genetic engineering examples. In the Figures folder you can find the code we used to generate these results. ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}